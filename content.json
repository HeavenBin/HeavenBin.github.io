{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"书单","date":"2018-02-11T06:45:21.404Z","updated":"2018-02-11T06:14:57.767Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-02-11T07:17:54.123Z","updated":"2018-02-11T07:17:54.122Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-02-11T07:17:48.540Z","updated":"2018-02-11T07:17:48.539Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-02-11T06:45:21.401Z","updated":"2018-02-11T06:14:57.769Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-02-11T06:44:56.113Z","updated":"2018-02-11T06:14:57.770Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-02-11T07:27:01.846Z","updated":"2018-02-11T07:27:01.845Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2018-02-11T05:55:35.860Z","updated":"2018-02-11T07:19:32.354Z","comments":true,"path":"2018/02/11/hello-world/","link":"","permalink":"http://yoursite.com/2018/02/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment","categories":[{"name":"这是分类","slug":"这是分类","permalink":"http://yoursite.com/categories/这是分类/"}],"tags":[{"name":"这是标签","slug":"这是标签","permalink":"http://yoursite.com/tags/这是标签/"}]},{"title":"空格","slug":"space","date":"2016-09-08T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2016/09/09/space/","link":"","permalink":"http://yoursite.com/2016/09/09/space/","excerpt":"","text":"Unicode定义的空格符号如下：[\\u0020\\u00A0\\u1680\\u180E\\u2002-\\u200D\\u202F\\u205F\\u2060\\u3000\\uFEFF]以下几种空格可以重点留意：\\u0020为普通半角空格\\u00A0为不换行的空格，对应HTML的&nbsp;(No-Break Space)\\u200B为零宽空格（Zero Width Space）\\uFEFF为零宽不换行空格（Zero Width No-Break Space）其中\\u2060为Unicode 3.2新增。在移除字符串首尾空白时，我们看看TJ的trim:123function trim(str)&#123; return str.replace(/^\\s*|\\s*$/g, '');&#125;别看这个库如此简单，但是每天的下载量达到1W+。先不说其它方面的BUG，就正则来说问题就不少。\\s匹配一个空白字符，等价于：[\\f\\n\\r\\t\\v\\u00A0\\u0020\\u1680\\u180E\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]可以看出很多第三方库在移除首尾空白时都没有考虑周全。下面我们看看浏览器内置的trim又是怎样的？示例代码：123456var s = '\\u0020\\u00A0\\u1680\\u180E\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u200B\\u200C\\u200D\\u202F\\u205F\\u2060\\u3000\\uFEFF'for (var i = 0; i &lt; s.length; i += 1) &#123; if (s[i].trim().length &gt; 0) &#123; console.log('\\\\u' + s.charCodeAt(i).toString(16)) &#125;&#125;输出结果如下：\\u200b\\u200c\\u200d\\u2060结论很明朗：浏览器内置的trim也并非100%准确，所以我推荐在严格场景下面使用自定义的trim函数。查看在线示例参考链接维基百科 - 空格","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript Parser资源总结","slug":"parser","date":"2016-07-16T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2016/07/17/parser/","link":"","permalink":"http://yoursite.com/2016/07/17/parser/","excerpt":"","text":"理解抽象语法树(AST)Abstract syntax tree - 维基百科抽象语法树在 JavaScript 中的应用 - 美团点评技术团队JavaScript的抽象语法树与语法解析通过开发 Babel 插件理解抽象语法树JavaScript ParserEsprimaAcornBabylonParser建议从Esprima开始学习，相比较于其它Parser文档和示例更加丰富和形象。Acorn的性能和效率比Esprima更胜一筹，但是文档比较匮乏。Babylon是Babel的JavaScript Parser，早期也是fork的Acorn，目前关注度不及其它Parser。推荐一种比较好的实践方式：从npm中的找出几个依赖于这些Parser的项目直接学习源代码。比如amd2cmd这个项目就是使用acorn将amd代码转换为cmd代码。周边工具AST explorer更直观的理解各个Parser生成的AST。ECMAScript Tooling各种用于AST以及辅助的相关工具，比如estraverse用于遍历AST，escodegen用于从AST生成源代码。Babel 插件手册","categories":[],"tags":[{"name":"JavaScript,解析器","slug":"JavaScript-解析器","permalink":"http://yoursite.com/tags/JavaScript-解析器/"}]},{"title":"使用SlimerJS将网页输出为PDF","slug":"slimerjs","date":"2016-06-28T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2016/06/29/slimerjs/","link":"","permalink":"http://yoursite.com/2016/06/29/slimerjs/","excerpt":"","text":"本文主要介绍本人在项目实践中通过SlimerJS将网页输出为PDF文档的过程，生成的PDF文档中的文本是矢量的，可以选择复制。虽然网上也有一些类似的分享，但是并没有将整个过程中的可能遇到的坑以及在Web开发中的一些技术细节讲述的比较清楚。软件清单：xvfbgtk3cupsfirefoxslimerjs本文使用的操作系统版本为CentOS 7.2。安装xvfb关于xvfb的介绍可以查看wiki，简单点说它就是用于处理程序中与图形化相关的功能，但是它不会在屏幕上展示任何图形输出。安装以后可以使用xvfb-run命令来运行headless slimerjs.1yum install xorg-x11-server-Xvfb安装FirefoxSlimerJS依赖于Firefox，目前支持的版本号介于38~ 46，其它版本官方无法保证测试结果。所以不推荐安装大于46或者小于38的版本。12wget https://ftp.mozilla.org/pub/firefox/releases/46.0.1/linux-x86_64-EME-free/zh-CN/firefox-46.0.1.tar.bz2tar xjvf firefox-46.0.1.tar.bz2注意这里我们下载Firefox的版本号为64的EME版本，普通版本在渲染复杂网页时可能会出现莫名的引擎级别错误。安装GTK3由于Firefox 46依赖于GTK3，所以这里我们需要安装GTK3。另外如果你的操作系统版本为CentOS 6.x，那么我推荐你放弃安装GTK3，而是直接升级系统。1yum install gtk3-devel安装CUPSCUPS是由苹果开发的通用Unix打印系统，如果没有安装CUPS，SlimerJS将网页渲染为PDF的时候将会挂起。1yum install cups安装SlimerJS12wget http://download.slimerjs.org/releases/0.10.0/slimerjs-0.10.0.zipunzip slimerjs-0.10.0.zip设置环境变量12// 这里设置为firefox文件夹下的的firefox可执行文件的路径export SLIMERJSLAUNCHER=PATH_TO_FIREFOX开始执行12cd PATH_TO_SLIMERJSxvfb-run ./slimerjs SCRIPT_PATH HTTP_PAGE_URL OUTPUT_FILENAME另外如果执行没有正常运行，可以加上—debug参数1xvfb-run ./slimerjs --debug test.js http://www.qq.com/ test.pdf参考代码12345678910111213141516171819202122232425262728293031323334353637383940var page = require('webpage').create()var system = require('system')if (system.args.length !== 3) &#123; console.log('Arguments error: xvfb-run ./slimerjs SCRIPT_PATH HTTP_PAGE_URL OUTPUT_FILENAME') slimer.exit()&#125; else &#123; var url = system.args[1] var renderPath = system.args[2] console.log('Page url is ' + url) console.log('Output path is ' + renderPath) page.paperSize = &#123; // magic number in my project width: '1500px', height: '1038px', shrinkToFit: true, printBGColors: true, printBGImages: true &#125; page.onLoadFinished = function() &#123; console.log('Finish loading page') // 有些时候分页不理想，需要删除一些节点 page.evaluate(function() &#123; var nodes = document.querySelectorAll('.bottom-line') for(var i = 0; i&lt; nodes.length; i += 1) &#123; nodes[i].parentNode.removeChild(nodes[i]) &#125; &#125;) console.log('Start rendering') page.render(renderPath) console.log('Finish rendering') slimer.exit() &#125; console.log('Opening page now ...') page.open(url)&#125;字体由于服务部署在Linux服务器上，网页渲染使用的字体与Windows和macOS区别还是很大的，比如Windows的微软雅黑在Linux是无法使用的。另外在安装字体上也有两种选择，第一是直接安装在服务器上，第二是作为Web Fonts从网页中引入。Flex布局早先我们尝试使用PhantomJS来完成此工作，虽然网上有说2.x支持Flex布局，但是我们的实践结果是不支持。SlimerJS在Flex布局上支持的很好，无需任何额外工作。Canvas绘制我们的网页使用了ECharts来进行图表绘制，ECharts底层使用了canvas来绘制图表。PhantomJS输出的PDF在这方面支持很差，Stacked Column中莫名的出现很多空白间隙。SlimerJS的表现要好得多，不过有些淡虚线比实际要粗一些，色彩也深一些。文档分页如果希望输出的PDF能够支持分页输出（方便分页打印），需要设置paperSize的Height来确定每页pdf的高度。不过这里也是有坑的，每页PDF高度会有几个像素的差距，导致会多出一个空白页。CSS适配渲染PDF的时候，浏览器进入打印模式，如果你没有专门适配样式，输出效果会很差。很多元素的背景颜色/文本颜色/背景图片不会展示出来。对于PhantomJS，网上有讨论说需要加上如下样式（我本人并未实践过此方案）：123456@media print &#123; body &#123; /*https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-print-color-adjust*/ -webkit-print-color-adjust: exact; &#125;&#125;对于SlimerJS，虽然paperSize存在相关设置（printBGColors/printBGImages），但是文本颜色似乎无法设置。所以我推荐在编写CSS的时候注意如下细节：将所有背景图片转换为Base64字符串直接在css中引入（幸好有webpack）所有设置元素文本颜色和背景颜色的样式需要兼容打印模式文本颜色相关的设置不支持inherited，这点尤其注意样例代码如下：1234567891011.someClassName &#123; background-color:red; color: #FFF;&#125;@media print &#123; .someClassName &#123; background-color:red !important; color: #FFF !important; &#125;&#125;最后的忠告不要寄希望于输出的PDF与网页中展示效果100%一致，几乎不可能（尤其是网页内容相对比较复杂的时候），最终效果或多或少都会有些瑕疵。","categories":[],"tags":[{"name":"SlimerJS","slug":"SlimerJS","permalink":"http://yoursite.com/tags/SlimerJS/"}]},{"title":"代码管理","slug":"code-management","date":"2016-06-25T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2016/06/26/code-management/","link":"","permalink":"http://yoursite.com/2016/06/26/code-management/","excerpt":"","text":"本文基本总结了我在DataEye前端项目代码管理方面的一些尝试。分享PPT在 slides.com 可能需要翻墙。Virtuality &amp; Reality借助于当下流行的VR，代码管理也从两个方面来讲解：虚（文件内容相关的管理）/实（文件的物理存储相关的管理）Version ControlGit与SVN：Git是分布式版本管理，SVN是中心化。无需中心服务器，本地自用git initMultiple Projects实际工作中开发人员每天都要与多个项目打交道，如何在多项目中开发中提高工作效率值得思考与学习20,0000,0000All in one和Windows的基础代码很像，Google的20亿行代码是用来驱动整个Google服务的，他们是一个整体！谷歌代码库已超过 20 亿行代码，他们是如何管理的？All in two indeed将业务代码(static)和可复用的代码(DataEye/dejs)分离Static所有的前端业务代码DataEye/dejs所有复用的组件代码，基于npm进行包管理npmnode package manager → package manager for javascript30,1298Branches分支管理已经成为日常工作的一部分（迭代新特性开发/临时BUG修复等）Under Control分支管理不是复制粘贴，需要微观宏观同时把控。提交/文件/修改历史都需要记录在案SVN你打算签出十个分支的所有代码吗？Workflow工作流管理将版本库分为稳定分支和临时分支Stable Branchesmaster用于管理已发布的线上代码，development用于日常开发Temporary Branchesfeature / bug / release临时分支需要在适当的时机合并到所有稳定分支。Code Review发现BUG，提高代码质量，促进知识共享，提升团队技术水平Continuous Integration提高软件质量，降低项目风险Unit Test隔离程序最小单元对其进行正确性测试，避免意外惊喜单元测试能够反哺程序自身的架构和设计。Coverage没有明显错误的代码 vs 明显没有错误的代码难以想象一行完全没有运行过的代码发布到生产环境会造成什么后果。Advice on Commits尽快提交/尽早提交/经常提交Advice on CodingBe social and betterGitHubnpmUpsourcecodecovSemaphoreci本文使用软件 violet一键发布到知乎/简书/Medium/GitHub等多个平台。","categories":[],"tags":[{"name":"代码管理","slug":"代码管理","permalink":"http://yoursite.com/tags/代码管理/"}]},{"title":"violet - 值得一试的写作同步小助手","slug":"violet","date":"2016-06-17T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2016/06/18/violet/","link":"","permalink":"http://yoursite.com/2016/06/18/violet/","excerpt":"","text":"她是什么violet 是一款面向写作爱好者的客户端同步工具。对于喜欢写点东西的人来说，一般都会活跃在多个写作平台（知乎、简书、Medium、GitHub）。往往我们倾向于在多个平台中选择一个作为主创平台。为什么只能选择一个平台？因为作品在各个写作平台之间同步异常麻烦。各个平台编辑器支持能力不一致，人的精力有限，你不可能在每个平台上使用不同的编辑器都发布一遍。即时可以复制粘贴，但大多数时候粘贴出的格式都并非如你所愿（尤其是代码）。随之而来的格式调整会花费大量时间，慢慢地你失去了同步多个平台的动力。作品发布以后频繁的小幅更新也慢慢地在摧毁你的创作动力。而罪魁祸首仅仅是缺少一款得心应手的工具！从今天起就不要为这些问题担忧了，violet 能帮你解除后顾之忧。功能统一使用流行的写作语言 Markdown在各大写作平台之间同步作品（一次编写，处处发布）特点跨平台，兼容Windows / Mac / Linux零网络请求，零客户端数据上报（写作平台接口除外）敏感信息加密存储在本地源代码开源支持写作平台知乎简书MediumGitHub其它(敬请期待)功能支持功能支持请前往：violet需求调查产品论坛和意见反馈请前往：violet客户支持服务平台DEMO本文链接：知乎简书GitHubMedium截图：名称来源我初生的女儿叫 小紫LicenseMIT","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"Better React 后续","slug":"better-react-2","date":"2016-03-11T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2016/03/12/better-react-2/","link":"","permalink":"http://yoursite.com/2016/03/12/better-react-2/","excerpt":"","text":"之前重构项目后根据个人实战经验写了一篇《Better React》，总结在React中传递props应该注意的事项。在后来与网友的讨论中发现行文总结不太严谨，于是乎再度发文，争取纠正其中某些纰漏之处，不至于误导他人。如果你还没有阅读《Better React》，推荐阅读之后再来阅读本文。缓存函数作为组件的prop传递不可取吗？之前的文章中不推荐缓存函数主要是因为下面这两个原因：类似的prop越多，外层缓存的函数越多，代码风格极其不自然如果函数依赖于局部变量，缓存的方式异常麻烦甚至于无法解决这里我们有必要再进行一些科普工作。 React组件可以接受函数作为prop，一般我们传递的时候有三种方式：在组件当前作用域定义局部变量在最外层的作用域定义全局变量作为组件自身的实例方法定义第一种方式写法最自然，但是危害最大，因为函数引用在父组件render的时候会一直变化。 第二种方式写法最蛋疼，函数引用不会变化，但是可以解决一些问题。第三种方式则是前两种方法的一个比较完美结合。至此，第一个原因提及的问题通过第三种方式可以解决。至于代码风格问题，因人而异。第二个原因提到的问题可能描述的不太详细，以致于会有人疑惑：为什么不把依赖的变量作为prop一同传入给子组件，这样反而更符合React的思想传还是不传，怎么做才是最佳实践？且往下看。应该使用EventEmitter吗？依赖是否需要作为props传递给子组件？这个我只能无奈地说要结合实际需求决定。当我们不使用EventEmitter的时候，看看我们怎么处理下面三个比较复杂的场景：_场景一 假设多个父组件引用了同一子组件，父组件的依赖又各不相同，这种方式需要将依赖全部加入到子组件的props里，必然引起子组件props爆炸。_props爆炸带来的就是一堆无谓的propType约束定义以及执行时的非空判断，代码臭味非常明显。倘若子组件未来再增加一些函数类型的props，这种方式简直就是灾难！而EventEmitter只需要给子组件绑定所需的事件交给子组件自己在合适的时机触发就可以了。_场景二_少数情况我们要考虑事件解绑，而置空函数类型的props必然导致rerender。当然你也可以通过设置开关变量来解决，但原本简单的逻辑变得更复杂了。如果函数类型的props很多，开关变量的数目也不会少，徒增很多无意义的代码。而EventEmitter只需要简单的解绑事件，也不会引起rerender。_场景三_在场景一的情况下，假设现在需要把子组件的事件处理结果同步到父组件的上级。在我们重构代码的时候，这种方式需要修改所有的父组件的代码才能满足需求。而EventEmitter只需要在最外层的组件给子组件绑定一个事件即可。更多的例子我就不一一列举了，相信真实世界的案例会更加多变和复杂。不过我们基本可以看出，场景越复杂EventEmitter的优势越明显。EventEmitter能够将组件之间的依赖层层解耦，从而能够从容的应对需求的不断变化。什么情况下不应该使用EventEmitter？首先我们必须承认，在开源的React组件中，使用EventEmitter非常少见。为什么呢？我个人认为主要是以下几个原因：浏览器不像Node.js，没有原生的EventEmitter实现，需要引入额外的库来支持；开源组件一般功能和需求规划较为明确，变化相对较少，使用EventEmitter收益非常有限。所以我推荐在功能通用或逻辑相对简单的组件中不必使用EventEmitter，而在功能复杂需求变化频繁的业务组件中优先使用EventEmitter。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"Redux三分钟入门","slug":"redux","date":"2016-02-20T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2016/02/21/redux/","link":"","permalink":"http://yoursite.com/2016/02/21/redux/","excerpt":"","text":"Redux三分钟入门什么是Redux？对于前端页面，从数据层面来说，无非就是一系列的状态组合。在传统的前端开发中，尤其是jQuery横行的年代，状态管理相关的理念一直没有什么起色。自Flux横空出世以来，各种解决方案层出不穷，百花齐放，Redux也是在这种环境下诞生的。如何描述Redux呢？简而言之，它就是一个状态容器，里面存储了整个应用的所有状态。Redux的核心思想就是要提供_可预测_的状态管理，这对日益膨胀的大型应用来说尤其重要。原谅我有一点标题党，因为对于从来没有听说过Redux的人来说，三分钟入门可能真的不够。预备知识Redux中有三个基本概念非常重要：store / reducer / action。Store顾名思义就是状态容器，Redux使用_createStore_这个API来创建一个全局的状态容器。这里有一点比较重要的就是：Redux应用只能有一个单一的Store我们暂时不用深究Redux为何如此设计。Reducer是一个纯函数，它的职责就是用来更新状态容器中的状态，_这也是Redux中更新状态的唯一途径_。Action是一个普通JavaScript对象，它是把数据从应用传递到状态容器的载体。将action传递到store中很简单，使用store.dispatch(action)就可以了。为了区分不同的数据来源，我们一般约定每个action都必须要有一个type字段。这样我们的reducer函数就能根据这个type字段来决定如何修改状态容器。掌握了上面的一些基本概念以后，我们就可以进入正题了，先上一段代码：DEMO1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Redux的两个核心API * createStore用于创建状态容器 * combineReducers用于将多个reducers合并成一个Reducer */let &#123;createStore, combineReducers&#125; = Redux/** * 状态容器的初始状态 * 一般用于同构应用，服务器端返回相关数据 */let INITIAL_STATE = &#123; counter: &#123; count: 0 &#125;&#125;/** * reducer函数，用于变更状态容器中的状态 * 如果action未知，则原样返回 * 永远不要修改state，返回一个全新的state */function counter(state = INITIAL_STATE.counter, action) &#123; switch (action.type) &#123; case &apos;INCREMENT&apos;: return &#123;count: state.count + 1&#125; case &apos;DECREMENT&apos;: return &#123;count: state.count - 1&#125; default: return state &#125;&#125;/** * 状态容器三个核心方法： * subscribe用于监听事件，每当dispatch的时候会执行 * dispatch用于分发action，这是改变状态容器中state的唯一途径 * getState获取当前state */let store = createStore(combineReducers(&#123;counter&#125;), INITIAL_STATE)store.subscribe(() =&gt; console.log(&apos;获取当前状态容器：&apos;, store.getState()))store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;) // count = 1store.dispatch(&#123; type: &apos;DECREMENT&apos; &#125;) // count = 0在线查看DEMO上面的DEMO代码逻辑大致如下：先定义reducer调用createStore创建store最后dispatch相关的action对应到具体业务中的过程可能是这样：用户点击某个按钮然后状态容器dispatch这个actionaction最后传达到reducer中reducer根据action的内容来修改状态状态容器状态发生改变后触发视图更新理解了上面的DEMO代码之后，Redux基本上就算入门啦！后续深入学习完上面的DEMO后，推荐你先看下Redux的一些基本理念，了解Redux背后设计的前因后果，然后再针对性地围绕Redux官网中文版学习（个人不太推荐从头到尾的精读，时间充裕的话请自便）。","categories":[],"tags":[{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"}]},{"title":"Better React","slug":"better-react","date":"2016-02-03T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2016/02/04/better-react/","link":"","permalink":"http://yoursite.com/2016/02/04/better-react/","excerpt":"","text":"Better React使用Ractive（一个MVVM框架）编写组件的时候，我就经常想获取用户当前传入的attributes。很无奈，Ractive并不支持此功能。为此我还专门提过一个issue。React开始流行的时候，作为MVVM的爱好者我其实是比较抵触的。后来发现势头不太对，感觉还是有必要了解下。于是就抱着试一试的心理，开始了React的学习历程。依稀记得当我首次接触props和state这对兄弟的时候，我的内心是十分激动的。随着React学习的愈发深入，就愈发觉得掌握props和state的使用，对于掌握React整个基础体系是有多么重要。今天本文就结合我自己的开发实践，讲讲使用props的一个基本原则。当然如果有更好的实践方法，烦请多交流。一个典型12345678910let Component = React.createClass(&#123; render() &#123; let handleClick = () =&gt; &#123; console.log('click handled') &#125; return ( &lt;SubComponent onClick=&#123;handleClick&#125; /&gt; ) &#125;&#125;)通常来说，子组件依赖父组件的某些变量、状态，或者需要更新父组件的UI这种需求还是很普遍的。上例中父组件将一个handleClick函数作为prop传入给子组件，handleClick由于其作用域的天然优势可以将子组件的依赖问题层层化解，异常的简单方便。这种将函数作为props传入子组件解决依赖问题的处理方式，也是目前React父子组件通信处理中一种非常普遍且流行的方式。但是既然以此为例，那它肯定是反面典型了！思考下面我们以一个稍微复杂点的例子来看看这种处理方式的缺陷， 查看演示效果。试试点击演示中的Add按钮，然后查看控制台输出。你会发现每点一次，底层的DumbCompoent的render都会触发一次。照理说DumbComponent没有任何的props的变更应该不会rerender，为什么呢？因为SmartComponent中传递prop的时候传递的是一个匿名函数，DumbComponent在shouldComponentUpdate判断的时候由于onClick的引用不同而返回true。如何修复呢？很自然的你可能会想到将onClick这个函数缓存起来，这样引用就不会一直变了。仔细思考一番其实这个方式并不可取，主要是因为：类似的prop越多，外层缓存的函数越多，代码风格极其不自然如果prop依赖于局部变量，缓存的方式异常麻烦甚至于无法解决解决方案避免将函数作为props传递，使用EventEmitter来对父子组件的依赖解耦。如果不了解EventEmitter，可以看看这篇文章。浏览器端的实现我推荐EventEmitter3。总结为了避免不必要的麻烦，请不要将函数传入props中，取而代之使用EventEmitter。遵循此原则，props始终传递基本类型或者只包含基本类型的对象。在今后的React学习之路上，当你了解ImmutableJS时，这个原则将会让你深深受益。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"【读书笔记】持续集成（软件质量改进和风险降低之道）之二","slug":"ci-2","date":"2015-12-16T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2015/12/17/ci-2/","link":"","permalink":"http://yoursite.com/2015/12/17/ci-2/","excerpt":"","text":"持续集成（软件质量改进和风险降低之道）第三章 利用CI减少风险品质意味着在没人看的时候也把事情做对。 by 亨利 福特我们的任务进度怎么样了？请查看最后一次构建测试覆盖率达到多少？请查看最后一次构建谁最后签入了代码？请查看最后一次构建利用CI，对每次变更建立一张“品质安全网”，更快地交付软件产品。当你在每次变更时按下“集成按钮”时，你就为尽早发现风险、经常发现风险奠定了基础。3.1 风险：没有可部署的软件场景：“在我的机器上是可行的”解决方案：消除IDE与构建过程的耦合，使用自动化构建脚本场景：与数据库同步（害怕修改或重构数据库和源代码、很难用不同的测试数据填充数据库、很难维护开发和测试环境）解决方案：将数据库相关融入到开发过程中，对数据库进行审查和测试3.2 风险：很晚才发现缺陷场景：对错误的修复导致了其它无关的错误浮现出来。我们对变更没有信心，因为我们不知道变更对其它部分的影响。解决方案：为变更的代码编写单元测试。3.3 风险：缺少项目可见性场景：没有工具显示整个项目的总体设计情况，没有类和关系的模型。解决方案：使用自动化文档生成工具。3.4 风险：低品质的软件场景：坚持编码标准场景：维持架构标准场景：重复的代码解决方案：使用相关的开发工具:Checkstyle / PMD / jDepend / Simian第四章 针对每次变更构建软件整个该死的宇宙必须被分解为一小块一小块，然后重新构造。 by 亨利 米勒有时候开发者就像鞋匠，为他的所有客户提供了鞋子，却忘记为他自己的孩子做鞋。4.1 自动化构建要记住，构建应该是按一下按钮的事。4.2 执行单命令构建构建脚本的逻辑过程：清理编译集成数据库测试审查部署4.3 将构建脚本从IDE分离无4.4 集中放置软件资产使用版本库来存放所有文件。4.5 创建一致的目录结构基于软件开发过程中的活动创建一致的、有逻辑的目录结构。构建过程中只需取出包含这个任务所需的源码和相关脚本，而不是所有的东西。4.6 让构建快速失败越有可能失败的的任务，应该越早在构建脚本中执行。4.7 针对所有环境构建改进构建脚本的可配置项，将构建脚本参数化。4.8 构建的类型和触发机制三个层次：个人、团队、客户。分别对应私有构建、集成构建、发布构建。触发机制：手工、定期执行、轮询变更、事件驱动。4.9 使用专门的集成构建计算机无4.10 使用CI服务器典型的CI服务器包含如下功能：以特定的时间间隔轮询版本库变更定期执行某种操作标识出安静期，在这段时间内部进行集成构建支持不同的构建脚本向相关人员发送电子邮件显示构建历史信息面板查看集成构建的信息为不同的项目支持多个版本控制系统4.11 执行手工集成构建使用手工集成构建不能保证坚持持续集成的实践。不利于提高品质的、更小、更频繁的集成。4.12 执行快速构建保持构建不超过10分钟；收集、分析构建测量数据；改进测试性能。4.13 分阶段构建减少构建时间的一种方式。先执行轻量级构建并对软件进行单元测试，然后执行重量级构建。4.14 这对您如何生效我的项目有七十亿行代码，怎么可能用这种方式？大项目主要考虑让构建保持迅速，定期执行而不是持续执行。将代码分解为独立的子项目。我们的软件太复杂了。我们 必须手工做一些事 或 “我们一切进行的的很好”这正是创建CI系统的理由，因为你可能在执行重复过程上花了很多时间。如果软件复杂，有很多依赖，那么持续集成就更有必要，需要创建一个系统将所有的部件组装在一起，执行测试和审查，确保所有部分运行正常。当然，这并不是说创建一个可重复的构建过程会很容易。将过程分解，而不是一次加入所有CI包含的东西。还有一点：CI是针对主线执行，分支必须在适当的时候合并到主线。","categories":[],"tags":[{"name":"持续集成","slug":"持续集成","permalink":"http://yoursite.com/tags/持续集成/"}]},{"title":"【读书笔记】持续集成（软件质量改进和风险降低之道）之一","slug":"ci-1","date":"2015-12-09T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2015/12/10/ci-1/","link":"","permalink":"http://yoursite.com/2015/12/10/ci-1/","excerpt":"","text":"持续集成（软件质量改进和风险降低之道）第一章 启程每天吃一个苹果和实际去做是两码事。 by Kathy Sierra1.1 针对每次变更构建软件一次构建不止是一次编译。它可能包含编译、测试、代码审查和部署以及其它一些事情。一次构建是将源代码放在一起，并验证软件可以作为一个一致的单元运行的过程。CI场景中的步骤通常是这样的：开发者提交代码到版本控制库，CI服务器轮询检查代码变更；CI服务器取出最新的源代码执行构建脚本，对软件进行集成；CI服务器向指定的成员发出电子邮件，提供构建结果的反馈信息；CI服务器继续轮询检查代码变更。通过一次构建，开发团队可以回答以下问题：软件组成部分是否能协同工作？代码复杂度如何？是否坚持了制定的编码标准？自动测试覆盖了多少代码？是否成功的通过了所有测试？应用程序是否满足性能要求？最近的开发是否存在问题你之所以希望“持续”地构建，就是为了得到快速的反馈。这样能在开发生命周期找到并修正问题。1.2 CI的特征CI需要具备的特征与版本控制库连接构建脚本某种类型的反馈机制（通常是邮件）集成源代码变更的过程（CI服务器）CI的子过程：源代码编译数据库集成测试 （没有自动化的、持续的测试的CI不能算是CI）审查 （自动化代码审查通过强制遵守规则来增加软件品质）部署 （任何时候都可以拿出能工作、可部署的软件）文档与反馈一个好的CI系统的关键特征就是“速度”。CI系统的本质是及时向开发者和项目风险承担着提供反馈信息。第二章 引入持续集成假定是所有麻烦之母假定一个方法会得到正确的调用参数假定开发者会坚持编码标准假定配置文件不会被覆盖或者修改持续集成在每次版本控制系统发生变化时就执行构建，这有助于减少项目中的假定。CI是一些基本实践。它不是软件开发中最炫目的工作，不会有用户说“哇，我真的喜欢你们上一个版本的集成方式”。它是软件开发的幕后工作，只有使用过CI的人才能体会到一致的、可重复的构建过程所带来的好处。检查软件的品质就是检查最新的集成构建，就这么简单！2.1 CI生活中的一天无2.2 CI的价值是什么减少风险减少重复过程在任何时间地点生成可部署的软件增强项目的可见性对开发团队的软件建立起更强大的产品信心减少风险缺陷的检测和修复变得更快软件的健康程度可以测量减少假定增强项目的可见性对当前构建状态和品质指标提供及时的信息观察到一些项目相关的趋势建立更强大的产品信心如果没有频繁的集成，团队成员会感到压抑，因为他不知道代码的修改所造成的影响。比如罚款！2.3 什么阻碍了团队使用CI增加了维护CI系统的开销（项目太复杂、额外工作太多）变化太大（增量实现，从日构建开始）失败的构建太多额外的硬件/软件成本2.4 如何进行持续集成确定：确定需要自动化的过程（编译、审查、测试、部署、数据库集成）构建：创建构建脚本分享：利用版本控制库让其它人用起来持续：在变更之后执行自动化的过程2.5 项目应该再何时以何种方式实现CI越早越好，越晚越拒绝改变。CI最终希望是在每次代码库变更时就执行构建，但是也可以从每日构建开始。早起可以不加入某些功能，比如自动化的回归测试2.6 集成的演进它不是突然冒出来的软件开发方法，是集成软件演进的成功。2.7 如何与其它开发实践配合单元测试编码标准重构小发行版本共同拥有代码，避免知识孤岛2.8 CI需要多少时间架设2.9 CI与您七项最佳实践：经常提交代码（每天至少一次）不要提交无法构建的代码（不能编译、无法通过测试、代码审查失败）立即修复无法构建的代码（优先级最高）编写自动化的单元测试必须通过所有测试和审查（不是90%或者99%，而是100%）执行私有构建（先在本地构建成功）避免签出无法构建的代码（等待新的变更或者帮助修复无法集成的构建）","categories":[],"tags":[{"name":"持续集成","slug":"持续集成","permalink":"http://yoursite.com/tags/持续集成/"}]},{"title":"捉虫记之decodeURIComponent","slug":"decodeURIComponent","date":"2015-06-29T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2015/06/30/decodeURIComponent/","link":"","permalink":"http://yoursite.com/2015/06/30/decodeURIComponent/","excerpt":"","text":"DataEye游戏分析平台有个实时日志功能，用于展示接收来自游戏客户端SDK上报数据以及游戏开发商使用HTTP接口发送的数据。第一版数据库收到什么样的JSON数据就直接返回给前端展示，终于有一天客户反馈页面脚本报错。一番调查，原来是数据库中存在特殊字符，于是要求后台全部url encode一次，前端decode就可以了。验证OK，于是测试发布。直到有一天用户反馈部分数据没有decode，还是类似%25XX的字符。第二版一番调查，原来是用户使用的是HTTP接口发送数据而不是SDK，所以部分数据自己encode了一次。然后服务器返回给前端页面的就是encode两次的数据。不就encode两次的问题嘛，页面decode两次就可以了嘛！于是无脑地吧decodeURIComponent(str)全部替换成了decodeURIComponent(decodeURIComponent(str))，发现问题居然解决了，找了另外的客户数据测试了下，验证也OK，于是发布。直到有一天某个另外的客户反馈页面脚本报错。第三版一番调查，根据URI Malformed Error这个罪证google得知，原来是源字符串不是合法的URL编码的字符串。虽然提示已经相当的明确了，但由于JSON数据量不少，字段较多，而且有些地方只需要decode一次，有些地方又需要decode两次，定位问题还是花了一些时间。最后发现罪魁祸首居然是用户输入的内容14%。解决方法12345678910111213141516function safeDecodeURIComponent(str) &#123; if (!str || typeof str !== 'string') return String(str) // encodeURIComponent不编码字符有71个：!， '，(，)，*，-，.，_，~，0-9，a-z，A-Z var twiceEncodedReg = /^(%\\w&#123;4,4&#125;|[!'()*\\-._~0-9a-z])+$/gi var encodedReg = /^(%\\w&#123;2,2&#125;|[!'()*\\-._~0-9a-z])+$/gi // 这里用try catch是因为即使正则匹配也有可能解码异常，异常或者不匹配时返回源字符串即可 try &#123; if (twiceEncodedReg.test(str)) return decodeURIComponent(decodeURIComponent(str)) if (encodedReg.test(str)) return decodeURIComponent(str) &#125; catch(e) &#123; &#125; return str&#125;相关链接Comparing escape(), encodeURI(), and encodeURIComponent()http://www.cnblogs.com/jhxk/articles/1634359.html最后的总结基础知识不扎实导致无法深入剖析问题所在，解决方案自以为然也就不足为怪了。—-7-21更新—-后续果然还是有后续！昨天突然一个客户又反馈有乱码，一番研究发现用户输入部分编码，部分未编码。上面的方法就不凑效了，于是花了几分钟做了如下改进：12345678910function safeDecodeURIComponent(str) &#123; var lastResult = str, current try &#123; while((current = decodeURIComponent(lastResult)) != lastResult) &#123; lastResult = current &#125; &#125; catch(e) &#123;&#125; return lastResult&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"白鹭引擎无废话快速上手","slug":"白鹭引擎无废话快速上手","date":"2015-05-02T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2015/05/03/白鹭引擎无废话快速上手/","link":"","permalink":"http://yoursite.com/2015/05/03/白鹭引擎无废话快速上手/","excerpt":"","text":"如果你从未听说白鹭引擎，也不了解其用途，那么本文可能并不适合你。阅读之前请确保你已了解白鹭引擎是一套基于TypeScript的游戏开发引擎，本文讲述了使用白鹭引擎开发HTML5项目的一般流程。安装白鹭引擎安装很简单，不论是windows还是mac，前往官网下载白鹭引擎的安装包，解压安装即可。参考链接：WindowsMac友情提示：至本教程完成时，白鹭引擎尚未提供适用于Linux系统的安装包。验证安装过程安装完成之后，打开终端输入egret，命令行会展示用法提示以及command列表。如果egret命令未找到，说明你的安装过程出错了。白鹭引擎的命令行工具是基于Node.js开发的，其源代码也是开源的。如果对某个命令有疑问或者对其实现感兴趣，可以直接查看其源代码更为方便。具体位置在白鹭引擎安装路径下的/egret/tools/lib/tools，比如build.js和publish.js分别对应egret build和egret publish命令。或者前往GitHub查看https://github.com/egret-labs/egret-core/tree/master/tools/lib/tools创建项目1egret create HelloWorld编译项目1egret build HelloWorld将TypeScript的源代码编译为原生JavaScript代码，默认编译为HTML5项目。如果需要编译为native项目，则加上--runtime native参数。运行项目1egret startserver HelloWorld白鹭引擎内部创建了一个基于Express的WebServer，当运行此命令后会自动在默认刘传奇中打开项目首页。发布项目1egret publish HelloWorld其它HelloWorld之后继续深入，请阅读http://docs.egret-labs.org/post/quitestart/helloworld/helloworld2.html。白鹭引擎相关开源项目：https://github.com/egret-labs关于TypeScript如果读者需要使用白鹭引擎开发游戏，那么系统地学习TypeScript是必经之路。虽然TypeScript的入门门槛不算高，但是完全掌握也需不少时间，不过对于开发一款游戏来说，掌握这门语言带来的收益应该远远大于学习的成本。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"RequireJS定义模块常用的两种方式","slug":"requirejs定义模块的两种方式","date":"2015-04-08T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2015/04/09/requirejs定义模块的两种方式/","link":"","permalink":"http://yoursite.com/2015/04/09/requirejs定义模块的两种方式/","excerpt":"","text":"RequieJS是一个遵循AMD规范的模块加载器，其定义模块的方式非常简洁，如下：1define(id?, dependencies?, factory);id为模块名称，字符串，可选参数dependencies为本模块依赖的其它模块，数组，可选factory为模块的实现，可以为一个对象或者函数，必填最常见的定义模块的方式如下：1234567891011121314define([&apos;jquery&apos;], function($)&#123; var myModule = &#123; add: function(a, b) &#123; return a + b &#125; &#125; /* * 这里将对象直接返回即可 * 返回函数也是可以的 * 如果没有任何返回值，那么模块作为依赖被引入的时候就是undefined */ return myModule&#125;)另外还有一种类似CommonJS的方式12345define([&apos;exports&apos;], function(exports)&#123; exports.add = function(a, b) &#123; return a + b &#125;&#125;)这种方式将CommonJS模块的转换为AMD风格的模块十分方便。如果一个模块同时兼容AMD、CommonJS或者无模块系统的传统页面，那么就需要用到UMD12345678910111213141516// root在浏览器里代表window对象，node里面则是global;(function (root, factory) &#123; // AMD if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123; define([], factory) &#125; else if (typeof exports === &apos;object&apos;) &#123; // CommonJS module.exports = factory() &#125; else &#123; // 暴露出的全局变量 root.moduleName = factory() &#125;&#125;(this, function () &#123; var myModule = &#123;&#125; return myModule&#125;))参考文档AMD模块定义规范AMD：浏览器中的模块规范","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"美妙的函数之isArguments","slug":"isArguments","date":"2015-04-01T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2015/04/02/isArguments/","link":"","permalink":"http://yoursite.com/2015/04/02/isArguments/","excerpt":"","text":"判断变量是否为Arguments对象没有想象中的那么简单，你可能会使用下面这种方法：1Object.prototype.toString.call(value) === &apos;[Object Arguments]&apos;我们先来看看著名的es5-shim是如何实现的。1234567891011121314var _toString = ObjectPrototype.toString;var isFunction = function(val) &#123; return ObjectPrototype.toString.call(val) === &apos;[object Function]&apos;;&#125;;var isArguments = function isArguments(value) &#123; var str = _toString.call(value); var isArgs = str === &apos;[object Arguments]&apos;; if (!isArgs) &#123; isArgs = !isArray(value) &amp;&amp; value !== null &amp;&amp; typeof value === &apos;object&apos; &amp;&amp; typeof value.length === &apos;number&apos; &amp;&amp; value.length &gt;= 0 &amp;&amp; isFunction(value.callee); &#125; return isArgs;&#125;;因为某些浏览器的buggy行为，这个方法不得不这么长。再看看lodash的实现：123456789101112131415161718192021222324var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;function isObjectLike(value) &#123; return !!value &amp;&amp; typeof value == &apos;object&apos;;&#125;function isLength(value) &#123; return typeof value == &apos;number&apos; &amp;&amp; value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt;= MAX_SAFE_INTEGER;&#125;function isArguments(value) &#123; var length = isObjectLike(value) ? value.length : undefined; return isLength(length) &amp;&amp; objToString.call(value) == argsTag;&#125;// Fallback for environments without a `toStringTag` for `arguments` objects.if (!support.argsTag) &#123; isArguments = function(value) &#123; var length = isObjectLike(value) ? value.length : undefined; return isLength(length) &amp;&amp; hasOwnProperty.call(value, &apos;callee&apos;) &amp;&amp; !propertyIsEnumerable.call(value, &apos;callee&apos;); &#125;;&#125;对比两种实现，es5-shim仅仅只是做了arguments对象特有的属性检测，而lodash的实现不论是从代码可读性还是严谨方面来考察都是极其完美的。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"程序员的强迫症","slug":"程序员的强迫症","date":"2014-07-28T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2014/07/29/程序员的强迫症/","link":"","permalink":"http://yoursite.com/2014/07/29/程序员的强迫症/","excerpt":"","text":"编程追求效率，却也讲究习惯。习惯改变之难，还真不能说那就不是个事儿，在技术圈子尤甚。当然，JavaScript这个圈子也不例外，比如这些：JavaScript语句后面应该加分号吗？eval is evil?== or ===?…上面的话题，个个是G点，分分钟引发高潮。就犹如Vim和Emacs、Windows和Linux等话题，一旦开篇随之而来的就是引经据典、长篇大论、你死我活、百态尽出。作为有格调的程序员，我们应追求效率。而非沉浸于无谓的争论，无端的争论往往因为恪守习惯，不善变通。就上面的话题进行争论，或许还有些”技术主义情怀”。但是下面的这些纯感性的习惯呢？不妨先看看：缩进用tab还是用空格，你喜欢哪一种?tab等于两个还是四个空格，你喜欢哪一种？对象的键值是紧凑连接，还是在冒号后加一个空格，你喜欢哪一种？变量声明，单行还是多行，你又喜欢哪一种？单行代码块的花括号，加还是不加？…这种习惯多如牛毛，以至“知音”着实难寻，因为实在是众口难调、各有所爱。也难怪Web Storm等编辑器在Code Style上花尽心思。一味地拘泥于习惯，在团队协作时就会患上强迫症。比如在别人的代码后面加个分号、补个空格，多加个空白行等等诸如此类。如果赶上心情好、情绪佳，或许会再花上一两小时，与他人舌战一番，定要分个胜负。此种行为既“无伤大雅”，也非“罪恶滔天”，情不自禁而已。不然“看着心里难受”，这种难受之于程序员，比1px的像素差之于产品经理可来的猛烈多了。于是乎加分号、补空格、按换行、删注释、调整顺序，忙得不亦乐乎。待大功告成，仿佛看见了光，解救了天解救了地也解救了自己，心情倍儿爽。如果你还在做这种“解救众生”的活，不妨试试JSHint来换个活法儿吧。什么是JSHintJSHint是一个用于检查JavaScript代码错误和潜在问题的工具。通过简单的配置，它可以强制约束团队保持一致的编码风格。JSHint配置文件的格式在项目根目录新加一个名称为.jshintrc的文件，加入相关配置即可，典型的配置如下：123456789&#123; \"node\": true, \"eqeqeq\": true, \"forin\": false, \"plusplus\": false, \"undef\": true, \"unused\": true, \"strict\": false&#125;json文件中的每一项都对应着一条规则。如果代码违反了规则，编辑器会给出错误提示。这方面Web Storm非常不错。JSHint详细配置文档，请看这里每个文件夹可以有单独的.jshintrc，作用范围就是其下JavaScript代码。还可以使用.jshintignore来排除将规则应用到当前目录指定的文件和文件夹。如何在Web Storm中使用JSHintCMD + , 打开偏好设置，输入JSHint搜索习惯配置项选中Inspections&gt;JavaScript&gt;Code quality tools&gt;JSHint点击JavaScript&gt;Code quality tools&gt;JSHint，勾选enable和use config file(default)即可配置详解强制选项(enforcing options)设置为true时，应用规则，对代码约束更严格。配置项释义好处bitwise禁止按位操作避免&amp;和&amp;&amp;手误camelcase变量名只允许驼峰camelCase和UPPER_CASE风格curly单行代码块必须使用分号防止潜在bugeqeqeq禁止使用==,!=避免类型转换es3兼容IE 6/7/8/9forin内部必须使用hasOwnProperty防止遍历原型链上的其它属性freeze禁止覆写原生对象immend(function(){}())indent2/4latedef禁止未定义而使用防止潜在bugnewcap类名首字母大写noarg禁止使用arguments.caller和arguments.callee难以优化，且已经被废除noempty禁止出现空代码块nonew禁止调用构造函数而不赋值plusplus禁止使用++, –不同语言含义不一致quotmarktrue/single/doubleundef禁止使用未定义的遍历unused禁止出现未使用的变量设置为vars不检查函数参数strict所有的函数都会使用es5的严格模式maxparams最多的形参5maxdepth嵌套深度maxstatements最多声明maxcomplexitycyclomatic complexitymaxlen设置一行最大的长度宽松选项(relaxing options)设置为true时，应用规则，对代码约束更宽松。配置项解释说明asi忽略句尾分号警告扩展阅读：1 , 2boss会允许在if，for，while里面编写赋值语句不检查判断条件中得赋值debug忽略debug语句eqnull允许 == nullesnext允许ES6语法ES6草案evil忽略evil警告expr在赋值或者函数调用的地方允许出现表达式大部分情况是手误funcscope允许在控制流程if等中定义变量默认为falseglobalstrict忽略全局使用strict的警告iterator忽略使用iterator属性警告并非所有浏览器支持lastsemic仅允许单行代码块不使用分号laxbreak忽略不安全的换行告警laxcomma忽略逗号风格告警loopfunc忽略在循环中定义函数告警建议设置为falsemaxerr设置JSHint最多警告数目默认50moz表明这是Mozilla扩展New in JavaScript 1.7multistr忽略多行字符串告警notypeof忽略不正确的typeof比较默认为false，不用管proto忽略使用proto 属性scripturl忽略使用”javascript:…”告警shadow忽略重复声明变量产生的告警sub忽略使用[]而不是.访问属性的告警supernew忽略使用诡异的构造函数告警示例validthis忽略严格模式在非构造函数中使用this函数内部使用noyield允许没有使用yield的generator function环境配置(Environments)配置项说明browser可以使用HTML5的新特性如FileReader等couchCouchDBdevel可以使用穷人版的debug工具，比如console、alertdojoDojo ToolkitjqueryjquerynodeNode.jsnonstandard允许流行而不标准的全局变量，比如escape和unescapephantomPhantomJSprotypejsprotypejsrhinoRhinoworker表明你的脚本运行在Web Worker中wshWindows_Script_HostyuiYUI币须网的JSHint币须网作为国内第一家应用比特币多重签名技术的电子商务平台，后台全部使用Node.js搭建，在团队协作上也需要JSHint这样的工具来进行检查和约束。我们正在使用如下的配置：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#123; \"bitwise\": true, \"camelcase\": false, \"curly\": true, \"eqeqeq\": true, \"es3\": false, \"forin\": true, \"freeze\": false, \"immed\": false, \"indent\": 2, \"latedef\": true, \"newcap\": true, \"noarg\": true, \"noempty\": true, \"nonbsp\": true, \"nonew\": true, \"plusplus\": true, \"quotmark\": true, \"undef\": true, \"unused\": true, \"strict\": false, \"maxparams\": 5, \"maxdepth\": 8, \"maxstatements\": 50, \"maxcomplexity\":false, \"asi\": true, \"boss\": false, \"debug\": false, \"eqnull\": true, \"esnext\": true, \"evil\": true, \"expr\": false, \"funcscope\": false, \"globalstrict\": true, \"iterator\": true, \"lastsemic\": true, \"laxbreak\": false, \"laxcomma\": false, \"loopfunc\": false, \"maxerr\": 50, \"multistr\": false, \"notypeof\": false, \"proto\":true, \"shadow\": false, \"supernew\": false, \"validthis\": false, \"noyield\": false, \"node\": true&#125;结语强迫症每个人或多或少都有一点，沉溺于习惯求稳而不求变也是人之本性。但如果要突破自我，不求变通怕是成不了气候。再则善于运用标准化的工具也算得上一大进步，程序员尤其如此，如果偶然之间随手解救了团队和自己也算得上造福一方吧。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"初识JavaScript Promises之二","slug":"初识JavaScript-Promises之二","date":"2014-07-14T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2014/07/15/初识JavaScript-Promises之二/","link":"","permalink":"http://yoursite.com/2014/07/15/初识JavaScript-Promises之二/","excerpt":"","text":"上一篇我们初步学习了JavaScript Promises，本篇将介绍Promise如何优雅地进行错误处理以及提升操作node.js风格[^1]的异步方法的逼格，没错就是使用promisify[^2]。异步编程中的错误处理人性的、理想的也正如很多编程语言中已经实现的错误处理方式应该是这样：1234567try &#123; var val = JSON.parse(fs.readFileSync(\"file.json\"));&#125;catch(SyntaxError e) &#123;//json语法错误 console.error(\"不符合json格式\");&#125;catch(Error e) &#123;//其它类型错误 console.error(\"无法读取文件\")&#125;很遗憾，JavaScript并不支持上述方式，于是“聪明的猴子”很可能写出下面的代码：123456789try &#123; //code&#125;catch(e) &#123; if( e instanceof SyntaxError) &#123; //handle &#125;else &#123; //handle &#125;&#125;相信没人会喜欢第二段代码，不过传统的JavaScript也只能帮你到这里了。上面的代码是同步模式，异步模式中的错误处理又是如何呢？1234567891011fs.readFile('file.json', 'utf8', function(err, data)&#123; if(err)&#123; console.error(\"无法读取文件\") &#125;else&#123; try&#123; var json = JSON.parese(data) &#125;catch(e)&#123; console.error(\"不符合json格式\"); &#125; &#125;&#125;)友情提醒：在node.js中你应该尽量避免使用同步方法。仔细比较第一段和第三段的代码的差异会发现，如此简单的代码竟然用了三次缩进！如果再加入其它异步操作，邂逅callback hell是必然的了。使用Promise进行错误处理假设fs.readFileAsync是fs.readFile的Promise版本，这意味着什么呢，不妨回忆一下：fs.readFileAsync方法的返回结果是一个Promise对象fs.readFileAsync方法的返回结果拥有一个then方法fs.readFileAsync方法接受参数与fs.readFile一致，除了最后一个回调函数返回Promise对象意味着，执行fs.readFileAsync并不会立即执行异步操作，而是通过调用其then方法来执行，then方法接受的回调函数用于处理正确返回结果。所以使用fs.readFileAsync的使用方式如下：1234//Promise版本fs.readFileAsync('file.json', 'utf8').then(function(data)&#123; console.log(data)&#125;)OK，让我们继续错误处理这个话题。由于Promises/A+标准对Promise对象只规定了唯一的then方法，没有专门针对catch或者error的方法，我们将继续使用bluebird。12345678// 带错误处理的Promise版本fs.readFileAsync('file.json', 'utf8').then(function(data)&#123; console.log(data)&#125;).catch(SyntaxError, function(e)&#123; //code here&#125;).catch(function(e)&#123; //code here&#125;)上面的代码没有嵌套回调，和本文开始的第一段代码的编写模式也基本一致。神奇的Promisify注：下面我们看如何对fs.readFileAsync方法进行promisify，依然是使用bluebird。12var Promise = require('bluebird')fs.readFileAsync = Promise.promisify(fs.readFie, fs)怎么样，就是如此简单！对于bluebird它还有一个更强大的方法，那就是promisify的高级版本 promisifyAll，比如：12var Promise = require('bluebird')Promise.promisifyAll(fs)执行完上面的代码之后，fs对象下所有的异步方法都会对应的生成一个Promise版本方法，比如fs.readFile对应fs.readFileAsync，fs.mkdir对应fs.mkdirAsync，以此类推。另外要注意的就是，Promise版本的函数除了最后一个参数（回调函数），其它参数与原函数均一一对应，调用的时候别忘了传递原有的参数。对fs的promisification还不能令我满足，我需要更神奇的魔法：1234567891011121314151617181920212223242526272829303132333435363738// redisvar Promise = require(\"bluebird\");Promise.promisifyAll(require(\"redis\"));// mongoosevar Promise = require(\"bluebird\");Promise.promisifyAll(require(\"mongoose\"));// mongodbvar Promise = require(\"bluebird\");Promise.promisifyAll(require(\"mongodb\"));// mysqlvar Promise = require(\"bluebird\");Promise.promisifyAll(require(\"mysql/lib/Connection\").prototype);Promise.promisifyAll(require(\"mysql/lib/Pool\").prototype);// requestvar Promise = require(\"bluebird\");Promise.promisifyAll(require(\"request\"));// mkdirvar Promise = require(\"bluebird\");Promise.promisifyAll(require(\"mkdirp\"));// winstonvar Promise = require(\"bluebird\");Promise.promisifyAll(require(\"winston\"));// Nodemailervar Promise = require(\"bluebird\");Promise.promisifyAll(require(\"nodemailer\"));// pgvar Promise = require(\"bluebird\");Promise.promisifyAll(require(\"pg\"));// ...少年，这下你颤抖了吗？注：如果你正在使用mongoose，除了bluebird你可能还需要mongoomise，它的优点在于：能够接受任意的Promise Library (Q/when.js/RSVP/bluebird/es6-promise等等)支持对多个数据库实例进行promisify能够对Model自定义静态私有方法进行promisify，而bluebird.promisifyAll不支持mongoomise + bluebird与仅使用bluebird性能相差无几，可能更好。我们币须网已经在生产环境中使用mongoomise + bluebird，目前为止一切安好。注：node.js风格函数指的是这样的一种异步函数，它接受的最后一个参数是异步操作完成之后的回调函数，这个回调函数的第一个参数接受执行错误的Error对象，第二个参数接受成功返回值）。promisify大概的意思就是根据一个node.js风格的异步方法生成另一个等价的Promise风格的方法（这个方法返回值是一个Promise，其它形参与原方法相同除了没有最后一个回调函数），这个名词我最早是看到bluebird使用。(未完待续 2014-07-15 23:40)","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"初识JavaScript Promises之一","slug":"初识JavaScript-Promises之一","date":"2014-06-27T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2014/06/28/初识JavaScript-Promises之一/","link":"","permalink":"http://yoursite.com/2014/06/28/初识JavaScript-Promises之一/","excerpt":"","text":"JavaScript有很多槽点，嵌套回调怕是千夫所指。很久之前，我一直使用async来处理JavaScript异步编程中的嵌套回调问题。当然我也大概的了解过一些其它旨在解决这些问题的类库，诸如EventProxy、Jscex、StepJS、thenjs。当我第一次看到Promises规范的时候，我根本无法理解它所带来的好处。譬如每个初次学习Promises的人都见过如下的示例代码：1234567891011121314//callbacksfunction callback(err, value)&#123; if(err)&#123; // do something return; &#125; //do other things with value&#125;//Promisespromise.then(function(value)&#123; //do something with value&#125;, function(err)&#123; //do other things with error&#125;)很难相信上面的代码会让人对Promises刮目相看。不过正如bluebird作者Petka所说，上面的代码是“最不诚实的比较”。所以我恳请你把类似的代码从你的记忆中擦出吧。不妨让我们再回到async的讨论上。async的问题在于它不能优雅地应对需求的变化，一旦业务逻辑有较大的变化，代码结构会进行大幅度的调整，而Promises却能够轻松的应对这种变化。待时机适宜我会进行详细的比较，首先让我们开始快速地了解Promises。Promises是什么Promises象征着一个异步操作的最终结果。Promises交互主要通过它的then方法，then方法接受一个回调函数，这个回调函数接受执行成功的返回值或执行失败的错误原因，错误原因一般是Error对象。需要注意的是，then方法执行的返回值是一个Promise对象，而then方法接受的回调函数的返回值则可以是任意的JavaScript对象，包括Promises。基于这种机制，Promise对象的链式调用就起作用了。Promises的状态Promise对象有三种状态：pending（初始状态）、fulfilled（成功执行）、rejected（执行出错）。pending状态的Promise对象可以转换到其它两种状态。上面的文本不够形象，不妨上些代码来加深对Promises的认识。注：由于主流的JavaScript环境（包括NodeJS）对Promises/A+标准的实现差强人意，我的示例均使用了第三方类库bluebird。12345678910111213141516171819var fs = require('fs')var Promise = require('bluebird')//改造fs.readFile为Promise版本var readFileAsync = function(path)&#123; //返回一个Promise对象，初始状态pending return new Promise(function(fulfill, reject)&#123; fs.readFile(path, 'utf8', function(err, content)&#123; //由pending状态进入rejected状态 if(err)return reject(err) //由pending状态进入fulfilled状态 return fulfill(content) &#125;) &#125;)&#125;//开始使用，调用其then方法，回调接受执行成功的返回值readFileAsync('./promise-1.js').then(function(content)&#123; console.log(content)&#125;)看了上面的代码以后，是不是觉得Promises其实并不复杂呢。OK，我们继续延续上面的代码，来简单比较一下传统回调和Promises的使用上的差别：1234567891011121314151617181920212223/** 简单比较一下传统方式和Promises方式* 需求：读取两个文件并打印内容* */ //callbacksfs.readFile('./promise-1.js', 'utf8', function(err, content1)&#123; //嵌套一次 console.log('#', content1) fs.readFile('./promise-1.js', 'utf8', function(err, content2)&#123; //第二次嵌套 console.log('##', content2) &#125;)&#125;)//PromisesreadFileAsync('./promise-1.js').then(function(content1)&#123; console.log('#', content1) //这里返回一个Promise对象 return readFileAsync('./promiscuitye-1.js')&#125;).then(function(content2)&#123; console.log('##', content2)&#125;)上面的代码都没有错误处理，这是一个后果很严重的坏习惯。不过今天我们的重点不在这里，而是分析上下两段代码的主要区别。第一段代码是传统的嵌套回调，在第二次打印的时候已经使用了两次缩进，而Promises链式调用then方法成功地避免了一次缩进（嵌套），维持了代码结构的相对平坦。上面的代码略显简陋，如果再加上错误处理，Promises毫无疑问将会大放光彩，有兴趣请关注后续章节。本章写到这里就结束了，相信大家已经对Promises的有了一个初步认识。规范文档往往很难理解，我没有过多的描述规范，因为我相信代码最能够解释一切。不过对规范文档有兴趣的可以自行阅读参考链接。最后我想强调的一点就是：Promises这种维持代码结构平坦的魔力在业务逻辑复杂多变的情况下是非常有用的。参考链接Promises/A+ 标准Bluebird未完待续(2014-06-28 00:59)","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Ajax编码问题","slug":"Ajax-Encoding","date":"2012-11-10T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2012/11/11/Ajax-Encoding/","link":"","permalink":"http://yoursite.com/2012/11/11/Ajax-Encoding/","excerpt":"","text":"前些天看到一个关于Ajax编码的问题，当时被提问者的描述绕的都想不清楚，今天闲来没事就整理下。原文地址在这里。问题描述我的前端页面为GBK，所以待发送的数据肯定也为GBK，而由ajax的特性其在发送前其会被自动转换为utf-8所以后台接收到的数据为utf-8的然后我的后台页面编码为UTF-8，同时设置了response header中的编码参数也为UTF-8，那么前端收到的数据应该也是UTF-8但前端页面为GBK，理论上来说这样会产生乱码，可是并没有，这是为什么呢？提问者的描述有点混乱，而且各种绕，一不小心就会踩到提问者设的坑。如何解决彻底解决这个问题你首先需要了解以下几个知识点：页面表单提交到后台的数据编码与页面编码一致通过javascript提交到后台的数据都会被转换为utf-8格式所以原则上这样理解，这个问题就差不多了：输入编码为UTF-8，后台以UTF-8方式输出，保证输入和输出一致那么自然就没有乱码问题。 要让别人相信自己，首先得自己相信自己，我们先不妨来几个测试。另外问题描述既然提到了后台的文本编码，我们也需要重点测试一下。测试工作准备以下页面：主页面index.phpajax后台页面utf8.phpajax后台页面gbk.php主页面 index.php，文本编码gbk12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"gbk\"/&gt; &lt;script src=\"http://s.segmentfault.com/js/jquery.js?12.11.5.1\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button type=\"button\" onclick=\"ajax_send('utf8')\"&gt;JS提交(utf-8)&lt;/button&gt; &lt;button type=\"button\" onclick=\"ajax_send('gbk')\"&gt;JS提交(gbk)&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; var ajax_send = function(encoding)&#123; var xhr = new XMLHttpRequest(), params = encodeURI('t=编码') xhr.onreadystatechange = function()&#123; if(this.readyState == 4 &amp;&amp; this.status ==200) alert(this.responseText) &#125; xhr.open('POST',encoding + '.php',true) xhr.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); xhr.send(params) &#125; &lt;/script&gt; &lt;/body&gt;utf8.php，文本编码utf-81234&lt;?phpheader('content-type:text/html;charset=utf-8');echo $_POST['t'];?&gt;gbk.php，与utf8.php内容相同，区别就是文本编码为gbk1234&lt;?phpheader('content-type:text/html;charset=utf-8');echo $_POST['t'];?&gt;启动Web Server，打开页面，分别点击按钮，都正确的弹出了“编码”二字，没有发现乱码现象。结论对于页面通过JS提交的数据：后台接口，只要保证输入输出的编码一致，提交的数据就会有乱码产生后台文件的文本编码以及前端页面的编码不会导致提交的数据返回时乱码，只要输入输出编码一致对于以上两个结论，读者还可以这样测试。1234&lt;?phpheader('content-type:text/html;charset=gbk');echo iconv(\"utf-8\",\"gbk\",$_POST['t']);?&gt;先将输入转码为gbk，然后输出同时设置为页面编码，这样也不会有乱码产生，但是服务端多了一道转码处理，效率不及直接输出utf-8。对于后台附加的一些输出，比如在gbk.php中最后加一行1echo \"中文\";这种情况会不会导致乱码呢？读者可以自己测试一下。深入稍微搞过前端的人都知道，使用script标签引入脚本的时候，有一个属性是charset用于指定脚本文件的编码。当页面编码与引入脚本的文本编码不一致的时候需要显式指定，否则就会容易造成乱码。现在我们仔细对比这两种场景的处理方式，不就是一模一样吗？只要保证输入输出的编码一致即可。唯一的区别就是一个是静态资源，一个是动态接口。你有可能会问，当输入输出指定的编码不一致时是不是就一定是乱码呢，浏览器又该如何解析呢？这个时候你就该来这里看看了。光棍节写博客，看来我是真光棍，真屌丝。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"iOS UIWebView Class Reference","slug":"iOS-UIWebView-Class-Reference","date":"2012-10-29T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2012/10/30/iOS-UIWebView-Class-Reference/","link":"","permalink":"http://yoursite.com/2012/10/30/iOS-UIWebView-Class-Reference/","excerpt":"","text":"原文地址属性allowsInlineMediaPlayback前端重点关注是否允许页内播放视频，默认值NO，使用原生的全屏控制。使用页面播放需要设置此属性为YES，并且video 元素要加上 webkit-playsinline属性。canGoBack是否可以后退，只读属性canGoForward是否可以前进，只读属性dataDetectorTypes在webview被转换为可点击的URL内容的数据类型。使用此属性可以指定譬如http链接，Email地址，电话号码等内容将自动转换为可点击的链接。当点击以后，webview寻找相应的应用程序来处理。delegate委托，用于回调通知页面的加载状态，比如已经打开、打开完成或打开错误等。keyboardDisplayRequiresUserAction前端重点关注显示键盘是否一定需要用户动作，默认值为YES，也就是用户必须主动点击可输入的表单元素以后才会显示键盘。设置为NO以后，页面可以通过JS脚本的focus事件显示键盘。loadingwebview是否还在加载，只读属性#mediaPlaybackAllowsAirPlay前端重点关注媒体播放是否允许Air Play???默认值为YESmediaPlaybackRequiresUserAction前端重点关注媒体播放是否需要用户动作主动触发，默认值为YES。也就是说默认情况无法自动播放音频和视频。那么默认设置下是不是一定无法自动播放呢？StackOverflow上找到一个方法解决此问题（没有测试）1234567var ifr = document.createElement(\"iframe\");ifr.setAttribute('src', \"http://mysite.com/myvideo.mp4\");ifr.setAttribute('width', '1px');ifr.setAttribute('height', '1px');ifr.setAttribute('scrolling', 'no');ifr.style.border=\"0px\";document.body.appendChild(ifr);requestwebview当前请求的URL，只读属性scalesPageToFit指定页面是否按比例缩放适应webview，并且用户可以更改缩放比例。默认值为NO，用户不能更改缩放比例。scrollViewwebview关联的scroll view，只读属性suppressesIncrementalRendering当页面完全加载到内存以后，webview是否禁止增量内容渲染，默认值为NOiOS 6.0版本支持##实例方法goBack加载历史记录当前页之前的页面goForward加载历史记录当前页之后的页面loadData:MIMEType:textEncodingName:baseURL设置页面内容，MIMIE type，编码，URLloadHTMLString:baseURL:设置页面内容loadRequest根据指定的URL进行异步连接reload重新载入当前页stopLoading取消当前页的加载stringByEvaluatingJavaScriptFromString前端重点关注在页面加载完成以后运行JavaScript脚本，运行脚本有如下注意事项：脚本运行不得超过10秒将要执行的脚本内存分配不得超过10M这里有一个比较详细的教程可以参考","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"一次跨域实践","slug":"A-Cross-Domain-Practice","date":"2012-07-26T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2012/07/27/A-Cross-Domain-Practice/","link":"","permalink":"http://yoursite.com/2012/07/27/A-Cross-Domain-Practice/","excerpt":"","text":"项目需求:对一个照片列表页面的每张图片在前端进行下载耗时统计，并定期上报。基本思路使用XMLHttpRequest下载图片，实现下载耗时统计。上报功能则一次上报localStorage存储的多张图片的统计信息，这里不做讨论问题难点使用XMLHttpRequest需要跨域访问图片服务器其它说明项目只服务于移动终端，本文的一切测试原则上只涉及Webkit系列的浏览器为了方便快捷地看到效果，后台使用Ruby语言的轻量级框架Sinatra使用127.0.0.1访问localhost模拟跨域图片请求项目文件前端测试主页面 test.html后台请求处理文件 myapp.rb一张测试图片 london.jpg，大小47714B代码预览test.html123456789101112131415161718192021222324252627&lt;!doctype html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;跨域获取图片的文件大小&lt;/h1&gt; &lt;button id=\"send\"&gt;Send Ajax Request&lt;/button&gt; &lt;script&gt; +function()&#123; var xhr = new XMLHttpRequest(), host = location.href.indexOf('localhost')&gt;-1?'127.0.0.1':'localhost', url = 'http://' + host + ':4567/img' xhr.onload = function(e)&#123; console.log(e) &#125; xhr.onerror = function(a)&#123; console.log(a) &#125; var send = document.getElementById('send') send.addEventListener('click',function()&#123; xhr.abort() xhr.open('GET', url, true) xhr.send(null) &#125;,false) &#125;() &lt;/script&gt;myapp.rb1234567891011require 'rubygems'require 'sinatra'get '/' do send_file 'test.html'end#跨域请求get '/img' do send_file 'london.jpg'end开始工作启动web server以后就开始我们的测试工作了。打开chrome及其控制台，输入 http://localhost:4567/，点击页面中的按钮，不出意外你会在chrome控制台看到下面的错误提示。1XMLHttpRequest cannot load http://127.0.0.1:4567/img. Origin http://localhost:4567 is not allowed by Access-Control-Allow-Origin.因为我们对跨域访问没有进行任何设置，所以自然无法通过浏览器内在的同源安全机制。实现跨域访问google如何实现跨域访问，很快找到了一种方法。在网站根目录放置crossdomain.xml的配置文件，就可以完美地实现跨域访问。难怪qq.com和taobao.com都不约而同的配置了这个文件，该文件的格式一般如下：12345&lt;cross-domain-policy&gt; &lt;allow-access-from domain=\"*.site.com\"/&gt; &lt;allow-access-from domain=\"*.site.net\"/&gt; &lt;allow-access-from domain=\"*.sitecdn.com\"/&gt;&lt;/cross-domain-policy&gt;经过一番测试，发现这样还是无法实现跨域访问。后来终于知道crossdomain.xml文件是flash跨域专用，而且据说已经被Adobe公司申请为专利。看来这条路是走不通了。于是继续google，终于在这里看到了一切关于我们想要的。，可惜w3c的文档总是那么地冗长而乏味，令人望而生畏。比如在介绍这个Access-Control-Allow-Origin的响应头如何设置时，看着这里的介绍是” origin-list-or-null | ““，我以为可以一次性设置多个origin，比如a.com,b.com,c.com。一番折腾之后发现这样设置和没有设置是一样的效果，如果不设置为星号就只能设置一个站点。那我们就暂时设置为”“吧，安全问题稍后再考虑！修改我们的后台代码，加入一个全局的过滤器设置响应头，下面是修改后的myapp.rb文件：1234567891011121314151617# myapp.rbrequire 'rubygems'require 'sinatra'get '/' do send_file 'test.html'end#跨域请求get '/img' do send_file 'london.jpg'endafter do headers\\ 'Access-Control-Allow-Origin' =&gt; '*'end现在我们重启web server和浏览器，继续输入http://localhost:4567/，点击页面中的按钮发起跨域请求，查看crhome控制台，没有发现错误，请求顺利完成。那就让我们看看`Network`中的跨域访问请求到底多了些什么：Access-Control-Allow-Origin:*Connection:Keep-AliveContent-Length:47714Content-Type:image/jpegDate:Fri, 27 Jul 2012 07:11:42 GMTLast-Modified:Fri, 27 Jul 2012 02:52:45 GMTServer:WEBrick/1.3.1 (Ruby/1.8.7/2011-12-28)X-Frame-Options:sameoriginX-Xss-Protection:1; mode=block果然我们设置的响应头Access-Control-Allow-Origin生效了，太神奇了！通过服务器和浏览器的协作，我们轻松地实现了跨域访问。现在看来W3C搞的这些跨域访问控制的标准还是比较靠谱的啊，如果说有什么缺点，那就是设置多个站点的时候麻烦了点（比如qq.com需要配置跨域访问控制的话），其它的缺点一时我还真说不出来。读取图片的文件大小目前为止，我们算是成功地实现了跨域请求，但是离我们的目标还差一点。我们还需要知道这个图片的文件大小，从之前服务器输出的响应头来看，应该就是Content-Length这个响应头了。那就修改下我们的页面代码，获取这个响应头吧：12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang=\"zh-CN\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;跨域获取图片的文件大小&lt;/h1&gt; &lt;button id=\"send\"&gt;Send Ajax Request&lt;/button&gt; &lt;script&gt; +function()&#123; var xhr = new XMLHttpRequest(), host = location.href.indexOf('localhost')&gt;-1?'127.0.0.1':'localhost', url = 'http://' + host + ':4567/img' xhr.onload = function(e)&#123; console.log(this.getResponseHeader('Content-Length')) console.log(this.responseText.length) &#125; xhr.onerror = function(a)&#123; console.log(a) &#125; var send = document.getElementById('send') send.addEventListener('click',function()&#123; xhr.abort() xhr.open('GET', url, true) xhr.send(null) &#125;,false) &#125;() &lt;/script&gt;刷新页面，打开控制台，点击按钮，一个红色的错误呈现在我们眼前：Refused to get unsafe header &quot;Content-Length&quot;怎么样让浏览器服软允许脚本获取这个响应头呢？还是继续去w3c的文档找找吧。很幸运，这个Access-Control-Expose-Headers似乎和我们的需求很匹配啊，不妨在过滤器中加入输出这个响应头来试一试：123456789101112131415161718# myapp.rbrequire 'rubygems'require 'sinatra'get '/' do send_file 'test.html'end#跨域请求get '/img' do send_file 'london.jpg'endafter do headers\\ 'Access-Control-Allow-Origin' =&gt; '*', 'Access-Control-Expose-Headers' =&gt; 'Content-Length'end重启web server，刷新页面，打开chrome控制台，点击按钮。没有任何错误，顺利输出两个数值：47714，45926。看来已经能够顺利的获取到Content-Length响应头，而且数值也很准确，和文件大小一致。但是这个responseText为什么少了接近2KB呢？还请高人解答。一切都很顺利，不过虽然只针对webkit系浏览器，至少也得测试下safari吧。打开safari及其控制台，输入url，点击按钮，居然抛出了和之前未设置Access-Control-Expose-Headers时一样的错误：Refused to get unsafe header &quot;Content-Length&quot;是不是浏览器缓存的问题呢？重启浏览器再测试，问题依旧。看来这应该就是safari的bug了。既然safari不支持，那就意味着我们前端脚本无法使用getResponseHeader了，那问题该如何解决呢？让我们再看看w3c上关于XMLHttpRequest Level 2的实现还有属性和函数我们可能用得上，继续找啊…终于发现XMLHttpRequest Level 2有一个onprogress事件和ProgressEvent对象，于是修改我们的页面代码如下：1234567891011121314151617181920212223242526272829303132&lt;!doctype html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;跨域获取图片的文件大小&lt;/h1&gt;&lt;button id=\"send\"&gt;Send Ajax Request&lt;/button&gt;&lt;script&gt; +function()&#123; var xhr = new XMLHttpRequest(), host = location.href.indexOf('localhost')&gt;-1?'127.0.0.1':'localhost', url = 'http://' + host + ':4567/img' xhr.onprogress = function(e)&#123; if(e.lengthComputable)&#123; if(e.loaded/e.total == 1)&#123; //invoke onload console.log(e.total) &#125; &#125; &#125; xhr.onerror = function(a)&#123; console.log(a) &#125; var send = document.getElementById('send') send.addEventListener('click',function()&#123; xhr.abort() xhr.open('GET', url, true) xhr.send(null) &#125;,false) &#125;()&lt;/script&gt;细心的同学可能会问为什么不在onload中执行相关操作，其实经我测试发现onload之后e.total和e.loaded已经被设置为0，虽然responseText依然可读，但是这与真实的文件大小有一点的误差。最后的完善虽然我们的目标已经完成，但是我们的工作还没有结束。因为服务端存在一个严重的安全隐患。我们草率地将Access-Control-Allow-Origin设置为”＊“，不可避免地为一些黑客攻击创造了便利条件。其实，既然我们的跨域访问只开放给部分信任的站点，那么我们只需要在后台的过滤器中判断请求来源是否属于白名单之中，如果存在则输出Access-Control-Allow-Origin响应头，内容为该站点域名。至于这个白名单的设计，可以参考Apache（之前一直误以为Apache的做法是业界的标准）。另外跨域访问控制一般针对的是Ajax请求，所以我们还可以在过滤器中加入一个是否是Ajax请求的判断(服务端判断请求头中是否包含X-Requested-With:XMLHttpRequest)，避免为普通的请求也加入Access-Control-Allow-Origin这个响应头。最后由于各浏览器对Access-Control-Expose-Headers的实现并不完善，所以这个响应头就显得异常鸡肋。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"关于容灾，前端能够做什么","slug":"关于容灾，前端能够做什么","date":"2012-03-27T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2012/03/28/关于容灾，前端能够做什么/","link":"","permalink":"http://yoursite.com/2012/03/28/关于容灾，前端能够做什么/","excerpt":"","text":"应用场景存在轮询的AJAX或者JSONP跨域请求的Web应用。比如我们有两台服务器，分别是a.com和a-bk.com，默认的轮询请求使用a.com；当a.com由于某种原因无法访问，需要按照一种事先约定的机制，将后续请求指向到备用服务器。同时当主服务器正常时，立即切换到主服务器。现实项目在我们的应用中，JSONP轮询的频率是每十秒一次。由于移动机房经常性的故障，导致客户长时间不能正常访问。于是客户经常向我们报障，试想如果此时，前端能够将用户的后续访问切换到我们的电信服务器，那该多好啊！虽然响应会慢一些，但是至少整个系统处于可用状态。容灾机制经过和同事们的一番讨论最后确定我们的容灾机制：连续两次请求没有及时应答则认定当前服务器不可用，切换到备用服务器；同时发起一个定时器，每55秒检测主服务器是否可用（访问主服务器上的一张43b的图片），一旦可用，立刻切换到主服务器。实现逻辑确定好容灾机制以后，剩下的就是编码了。不过编码之前其实还有一个隐藏的重大问题，那就是我们如何确定这个请求是否超时？因为我们的跨域JSONP请求都是使用script tag，而且需要兼容IE 6,自然没有什么类似的ontimeout事件去检测。那我们就只有自己动手来处理了。对于单个请求超时的判断，我们可以在主函数启动时设置一个状态量为false，回调函数中修改这个值为true。由于需要尽量避免修改原函数逻辑，这里用到了 AOP 技术，详细参见这里方案一每一次发起JSONP请求后，开启一个setTimeout 8秒后去检测状态量是否被修改（变量由回调函数修改），依此判断响应成功与否。方案二建立一个对象，给每一次请求标记ID，将其使用的服务器地址和响应结果记录下来；在第N次请求发起之前，判断第N-2次和N-1次请求是否使用相同的服务器，如果是，当这两次请求都没有及时响应时切换到备用服务器。比较结果方案一对每次请求都在下一次轮询之前就决定它是成功还是失败。我在生产中设置的值是6.5秒，但发现许多客户经常在主服务器和备用服务器上来回切换。方案二的好处在于，首先没有发起额外的setTimeout来监测请求成功是否响应，其次对于每一次请求方案二的超时时间实际是一个动态的值。对比下就知道方案一对每个请求的超时容忍度都是相同的6.5秒，最大也只能是10秒，而方案二第N-2次的超时容忍时间是20秒，第N-1次是10秒。所以严格意义上来讲，方案二更宽容也更加合理。编码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/*** @description 网络模块* @property &#123;Number&#125; DETECT_CYCLE 切换到备用服务器后，监测主域名的周期，单位为秒，周期长度最好不要设置为10的倍数，便于调试观察*/_.net = &#123; DETECT_CYCLE:55 &#125;;/*** @description 为跨域请求函数注入容灾备份机制，需要将原函数的请求服务器地址改成_.net['funcname_current_server'];* 实现原理：使用对象存储每一次请求使用的服务器地址和请求结果，然后在每一次请求之前，判断前两次使用相同服务器的请求是否都不成功。* 如果都不成功表明连续两次请求失败则切换到备用服务器* @param &#123;Object&#125; entry 入口函数&#123;context:执行环境,name:函数名称&#125;* @param &#123;Object&#125; exit 回调函数&#123;context:执行环境,name:函数名称&#125;* @param &#123;Object&#125; settings 服务端配置&#123;server:主域地址,backupServer:备选服务器地址，数组，长度为0则不启用容灾机制,serverImg:监测主域名可用的图片&#125;* @param &#123;Function&#125; forward 动态判断是否在入口函数继续执行注入的容灾机制* @usage 参见/user/js/map.js* @dependacy &#123;Function&#125; _.inject*/_.net.backup = function(entry,exit,settings,forward)&#123; var server = settings.server,currentServer = entry.name + '_current_server'; _.net[currentServer] = server; //没有备用地址则不启动容灾备份机制 if(!settings.backupServer || !_.isArray(settings.backupServer) || !settings.backupServer.length) return; var interval = entry.name + '_interval',//切换到备用以后发起定时器key_name total = entry.name + '_total',//总的请求次数key_name status = entry.name + '_status',//维护各次请求的地址和请求结果key_name serverAvailable = entry.name + '_server_available';//表明当前主服务器是否可用的key_name //主服务器可用时立即切换，并重置对应的变量 var resetServer = function()&#123; _.net[serverAvailable] = true; _.net[currentServer] = server; clearInterval(_.net[interval]); &#125;; //筛选服务器算法，如果当前使用主服务器则切换到备用，如果已经是备用，有多个备用时则切换到下一个备用，只有一个备用是切换到主服务器 var selectServer = function()&#123; if(_.net[currentServer] == server)&#123; return settings.backupServer[0]; &#125;else&#123; var len = settings.backupServer.length; if(len ==1) return server; var index = _.indexOf(settings.backupServer,_.net[currentServer]); return settings.backupServer[index+1] || settings.backupServer[0]; &#125; &#125;; _.net[serverAvailable] = true; _.net[interval] = null; _.net[total] = 0; _.net[status] = &#123;&#125;;//格式：&#123;1:['http://a.net/',true], 2:['http://a.net/']&#125; entry.start = function()&#123; if(typeof forward == 'function')&#123; if(!forward())return; &#125; _.net[total] += 1; var count = _.net[total]; //存储当此请求使用的服务器地址和响应结果 _.net[status][count-1] = []; if(count &gt; 2)&#123; var prev = _.net[status][count-2], prevPrev = _.net[status][count-3]; //上两次请求使用同一个服务器且都失败了，则切换服务器 if(prev[0] == prevPrev[0] &amp;&amp; !prev[1] &amp;&amp; !prevPrev[1])&#123; var usingServer = _.net[currentServer] == server, old = _.net[currentServer]; if(usingServer)&#123; _.net[interval] = setInterval(function()&#123; var img = new Image(); img.onload = resetServer; img.src = settings.serverImg + (settings.serverImg.indexOf('?')&gt;-1?'&amp;':'?') + 't=' + new Date().getTime(); &#125;, _.net.DETECT_CYCLE*1000); &#125; //如果只有一个备用服务器且备用不可用则立即切换到tbo if(!usingServer &amp;&amp; settings.backupServer.length==1)&#123; resetServer(); &#125;else&#123; _.net[currentServer] = selectServer(_.net[currentServer]); _.net[serverAvailable] = _.net[currentServer] == server; &#125; if(settings.errorHandler)&#123; settings.errorHandler(old,_.net[currentServer]); &#125; &#125;else&#123; //如果备用服务器一直正常，那么需要一直检测主域名是否可用，如果可用立即切换到主域名 if(_.net[currentServer] != server)&#123; if(_.net[serverAvailable])&#123; resetServer(); &#125; &#125; &#125; //删除冗余信息，保证数组长度为2 delete _.net[status][count-3]; &#125; //记录当此请求使用的服务器地址 _.net[status][count-1][0] = _.net[currentServer]; &#125;; exit.start = function()&#123; //标记本次请求成功，不成功的请求数组长度为1 _.net[status][_.net[total]-1][1] = true; &#125;; _.inject(entry); _.inject(exit);&#125;;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"AOP in JavaScript","slug":"AOP-in-JavaScript","date":"2012-03-17T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2012/03/18/AOP-in-JavaScript/","link":"","permalink":"http://yoursite.com/2012/03/18/AOP-in-JavaScript/","excerpt":"","text":"基本概念面向侧面的程序设计（aspect-oriented programming，AOP，又译作面向方面的程序设计、观点导向编程）是计算机科学中的一个术语，指一种程序设计范型。该范型以一种称为侧面（aspect，又译作方面）的语言构造为基础，侧面是一种新的模块化机制，用来描述分散在对象、类或函数中的 横切关注点 （crosscutting concern）。使用目的需要增强或者修改原有函数的功能，但并不直接修改原函数的内部逻辑。比如为函数添加 前置 和 后置 操作。最常见的应用比如计算函数执行的时间、函数执行时的日志记录。实际应用在系统中有两个函数，func1和func2，func2是func1代码末尾的JSONP（跨域请求）回调。这两个函数内部逻辑相对复杂，代码也较多。func1的执行频率是10秒一次，而客户端与服务器之间的网络并不能保证永远正常连接，除了后端有DNSPOD、反向代理等容灾方案，前端也要做一些容灾工作。如何容灾 ？就是在发现连续两次请求失败，就认定主服务器不可用，立刻在前端切换到备用服务器。确定好这个思路以后剩下的就是在服务端添加各种配置，然后在前端为原有的func1加入请求超时的统计功能。超时统计无非就是在func1的开始设置一个变量，func2结束后还原为初始值，如果在指定的超时时间段内发现变量未还原则判定为请求超时。这段代码与原函数func1和func2均无逻辑关联，所以尽量不直接修改这2个函数的代码，加之func1和func2已经相对复杂，若直接修改函数内部代码将导致代码复杂度加倍而且难于维护。于是乎，AOP就派上用场了！实现代码123456789101112131415161718192021222324252627var _ = function(id)&#123;return document.getElementById(id);&#125;;var GFRAME = &#123;&#125;;GFRAME.name = 'GFRAME';GFRAME.func1 = function(x)&#123; console.log(this.name,x);&#125;/** * @description AOP in JavaScript，不直接修改原函数而增强函数功能。未考虑前置操作的函数返回值的情况 * @param &#123;Object&#125; args &#123;context:执行环境，name:函数名称，start:前置操作，end:后置操作&#125; **/_.inject = function(args)&#123; var origin = args.name, context = args.context || window, start = args.start || (function()&#123;&#125;), end = args.end || (function()&#123;&#125;); var temp = context[origin]; if(typeof temp != 'function') throw Error(origin + ' is not a function in the given context.'); if(typeof start != 'function' || typeof end != 'function' ) throw Error('start and end is not a function in the given context.'); context[origin] = function()&#123; start.apply(this,arguments); var ret = temp.apply(this,arguments); end.apply(this,arguments); return ret; &#125;;&#125;;使用方法1234567891011_.inject(&#123; name:'func1', context:GFRAME, start:function(x)&#123; console.log('start',this.name,x); &#125;, end:function(x)&#123; console.log('end',this.name,x); &#125;&#125;);GFRAME.func1('test');输出结果123start GFRAME testGFRAME testend GFRAME test扩展阅读AOP@维基百科你相信么，只需一个函数5行JS代码即可在Javascript中实现完整的AOP功能","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript Template Engine","slug":"JavaScript-Template-Engine","date":"2012-02-05T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2012/02/06/JavaScript-Template-Engine/","link":"","permalink":"http://yoursite.com/2012/02/06/JavaScript-Template-Engine/","excerpt":"","text":"设计目的减少现有代码中的字符串拼接操作，增强代码的可维护性。实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* * @description An Easy Template in JavaScript, it is designed to reduce the string concatention work, * to make the gigantic code more readable and maintainable. */function Template(tmpl,source)&#123; //add all template tasks to this array this.task = []; if(tmpl) this.task.push([tmpl,source]);&#125;/* * @description core function,hanlde two cases: typeof dataSource is either object or array * when the type of dataSource is array,you'd better confirm that the fields in every object is the same. */Template.format = function(template,dataSource)&#123; //default variable flags var start = '&#123;', end = '&#125;'; if(dataSource &amp;&amp; dataSource.slice &amp;&amp; dataSource.length)&#123; var retStr = [], formatted, len = dataSource.length, regMap = &#123;&#125;; //restore the RegExp,avoid to construct them repeatedly. for(var regKey in dataSource[0])&#123; regMap[regKey] = new RegExp(start + regKey + end,'g'); &#125; for(var index in dataSource)&#123; formatted = template; for(var key in dataSource[index])&#123; formatted = formatted.replace(regMap[key],String(dataSource[index][key])); &#125; retStr.push(formatted); &#125; return retStr.join(''); &#125;else&#123; for(var key in dataSource)&#123; template = template.replace(new RegExp(start + key + end,'g'),String(dataSource[index][key])); &#125; return template; &#125;&#125;;Template.prototype.add = function(tmpl,source)&#123; //add one template task this.task.push([tmpl,source]);&#125;;/* * @description handle all tasks,and return the final string. * when this method is invoked,you can reuse the instance. */Template.prototype.end = function()&#123; var retStr = []; for(var index in this.task)&#123; retStr.push(Template.format(this.task[index][0],this.task[index][1])); &#125; this.task.length = 0; return retStr.join('');&#125;;##使用方法12345678910111213141516171819202122232425&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;script src=\"jTemp.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id=\"MenuItems\"&gt; &lt;li class=\"nav\"&gt;&lt;a href=\"&#123;href&#125;\"&gt;&#123;text&#125;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var ul = document.getElementById('MenuItems'); var dataSource = [ &#123;text:'首页',href:'http://www.oschina.net/'&#125;, &#123;text:'开源软件',href:'http://www.oschina.net/'&#125;, &#123;text:'讨论区',href:'http://www.oschina.net/'&#125;, &#123;text:'代码分享',href:'http://www.oschina.net/'&#125;, &#123;text:'资讯',href:'http://www.oschina.net/'&#125;, &#123;text:'博客',href:'http://www.oschina.net/'&#125;, &#123;text:'Android',href:'http://www.oschina.net/'&#125; ]; var tmpl = new Template(ul.innerHTML,dataSource); ul.innerHTML = tmpl.end(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;额外说明上面的例子更加偏向于一个穷人版的模板引擎（变量替换），如果这是你需要更加强大的例子，不妨看看 jQuery 的作者John Resig在几年前的 作品。不过模板引擎的发展在JavaScript圈子里面可谓日新月异，比较出名的有：mustachehandlerbarsejsartTemplate (国产)","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JSONP Memory Leak","slug":"JSONP-Memory-Leak","date":"2011-10-21T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2011/10/22/JSONP-Memory-Leak/","link":"","permalink":"http://yoursite.com/2011/10/22/JSONP-Memory-Leak/","excerpt":"","text":"什么是JSONP？JSONP （JSON with Padding）是资料格式 JSON 的一种“使用模式”，可以让网页从别的网域要资料。另一个解决这个问题的新方法是跨来源资源共享。由于 同源策略 ，一般来说位于 server1.example.com 的网页无法与不是 server1.example.com 的服务器沟通，而 HTML 的 script 元素是一个例外。利用 script元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的 JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。以上内容摘抄自：JSONP@维基百科简而言之，JSONP就是WEB前端开发中最常用的一种 跨域请求 数据的方式。使用场景JSONP是一种常用的跨域请求脚本的方式。如果页面不涉及轮询，那也不是什么大问题。但是当页面中存在 轮询 跨域请求时，问题就被无数倍的放大了。所以需要额外小心由此带来的 内存泄漏！当然毫无疑问，IE系列始终是最让人纠结的。跨域加载脚本通常我们使用下面的方式来加载一段脚本：12345var script = document.createElement('script');script.src = 'http://www.abc.com/somepage?callback=check';script.id = 'JSONP';var head = document.getElementsByTagName('head')[0];head.appendChild(script);对于一般的WEB应用程序这并不存在什么问题，但是一旦你的应用程序中使用到了轮询，这样只增加节点而不删除，将导致内存不断增长，增长的比例和加载脚本执行的内容也有很大的关系。读者可以尝试向页面不断载入jquery源代码，设定轮询间隔为2s，可以看到内存的增速达到几十M每秒。所以十分有必要在脚本执行完成以后删除这些script节点。删除加载的script节点12345678var script = document.createElement('script');script.src = 'http://www.abc.com/somepage?callback=check';script.id = 'JSONP';script.type = 'text/javascript';script.charset = 'utf-8';var head = document.getElementsByTagName('head')[0];head.appendChild(script);head.removeChild(script);这样的方式可以吗？显然不行！因为加载的脚本还没来的及执行就被删除了，所以我们需要 让加载的脚本先执行一会儿 。曲线救国123setTimeout(function()&#123; head.removeChild(script);&#125;,200);不得不说，这样的解决方式很不优雅，要是脚本200ms内还没有执行完毕，肯定会出问题。所以需要保证脚本执行完之后自动删除。加载script后自动删除节点12345678910111213141516var script = document.createElement('script');head.appendChild(script);if(script.readyState)&#123; script.onreadysctatechange =function()&#123; //注意使用this避免内存泄漏 if(this.readyState == 'completed' || this.readyState == ''loaded) this.parentNode.removeChild(this); &#125;;&#125;else&#123; script.onload =function()&#123; //注意使用this避免内存泄漏 this.onload = null; this.parentNode.removeChild(this); &#125;;&#125;script.src = url;幸好IE支持 onreadysctatechange 事件，而标准浏览器支持 onload 事件来判断脚本的执行状态。IE浏览器下的问题那么是不是现在我们的问题就解决了呢？测试后发现这样的解决方案不能完全避免内存的不断增长，标准浏览器包括Chrome随着轮询的都会有内存增长的现象，不过增长程度微乎其微（轮询间隔2m，增长速度也只有4k-8k）。但是IE会有十几到几十K的内存增长。你会看到我们在script加载完成之后已经将script元素删除了，为什么内存还会不断增长呢？很简单，这就是 内存泄漏 现象。重用script节点标准浏览器对script标签的处理就是每个script标签的地址（src）只能设置一次，后续的设置能够改变地址，但是对应地址的脚本内容不会执行，不管script标签是页面预留的还是动态插入。IE下面则很神奇，使用js动态插入的script标签不遵守这一规则。于是我们只需要动态的插入一个id已知的script标签，然后不断地改变它的src，以此方式加载的脚本都会执行。而且这个script节点也不必删除，下次请求继续重用即可。这样IE下面的内存泄漏问题就解决了！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273var _ = function(id)&#123;return document.getElementById(id);&#125;;_.ajax = function()&#123;&#125;;(function()&#123; //存储超时或异常的JSONP请求 _.ajax.TIMEOUT_REQUEST = []; //超时设定 _.ajax.TIMEOUT = 5000; if(_.isIE)&#123; //JSONP重用标签的id _.ajax.SCRIPT_ID = 'ie_script_for_jsonp'; //重用标签是否被JSONP请求占用 _.ajax.SCRIPT_USED = false; //被占用时JSONP请求等待的时间 _.ajax.WAIT_TIME = 100; //上次JSONP请求的时间 _.ajax.LAST_USED_TIME = 0; var script = document.createElement('script'), head = document.head || document.getElementsByTagName('head')[0]; script.setAttribute('id',_.ajax.SCRIPT_ID); script.onreadystatechange = function()&#123; if (this.readyState == \"loaded\" || this.readyState == \"complete\")&#123; _.ajax.SCRIPT_USED = false; &#125; &#125;; head.appendChild(script); &#125;&#125;)();/** * @description 轮询JSONP请求调用，IE浏览器采用重用Script节点方式。 * @param url 手动加上callback参数，自动追加了时间戳 **/_.ajax.jsonp = function(url)&#123; if(!navigator.onLine)&#123; _.ajax.TIMEOUT_REQUEST.push(url); return; &#125; var script, now = new Date().getTime(), requestUrl = url + (url.indexOf('?')&gt;-1?'&amp;timestamp=':'?timestamp=') + now, head = document.head || document.getElementsByTagName('head')[0]; if(_.isIE &amp;&amp; _.isIE &lt; 9)&#123; script = document.getElementById(_.ajax.SCRIPT_ID); //节点被占用 if(_.ajax.SCRIPT_USED)&#123; if(_.ajax.LAST_USED_TIME === 0) _.ajax.LAST_USED_TIME = now; //已经超时 if((now - _.ajax.LAST_USED_TIME) &gt; _.ajax.TIMEOUT)&#123; _.ajax.LAST_USED_TIME = now; if(_.ajax.TIMEOUT_REQUEST.length&gt;=1000) _.ajax.TIMEOUT_REQUEST.length = 0; _.ajax.TIMEOUT_REQUEST.push(script.src.split('&amp;timestamp=')[0]); script.src = requestUrl; //没有超时则等待 &#125;else&#123; setTimeout(function()&#123;_.ajax.jsonp(url);&#125;,_.ajax.WAIT_TIME); &#125; &#125;else&#123; _.ajax.SCRIPT_USED = true; _.ajax.LAST_USED_TIME = now; script.src = requestUrl; &#125; &#125;else&#123; script = document.createElement('script'); head.appendChild(script); script.onload = function()&#123; this.onload = null; this.parentNode.removeChild(this); &#125;; script.onerror = function()&#123; _.ajax.TIMEOUT_REQUEST.push(this.src); &#125;; script.src = requestUrl; &#125;&#125;;测试结果对上述代码测试，使用 sieve 结合任务管理器，发现此方法引起的内存泄漏和chrome下面的差不多都在4K左右，测试环境是IE 8。123456var i = 0;window.onload = function()&#123; setInterval(function()&#123; _.ajax.jsonp('data.js'); &#125;,1000);&#125;;data.js 的内容：1i++;后续说明其实之所以存在内存泄漏，是因为IE的 removeChild 方法存在内存泄漏的问题。对于这一点 jQuery 的 empty 方法已经考虑到。关于removeChild导致内存泄漏的问题，很早就被发现了，具体请看这里。一般的框架都有各自的删除节点的方式来避免内存泄漏问题，下面是 EXT 的处理方式：12345678910111213141516171819_.dom = function()&#123;&#125;;/** * @description 采用ext的处理方式，也可以对删除的元素使用outerHTML=''，但是此方法不通用，某些元素的outerHTML属性只读 * @param n 要删除的HTML节点 */_.dom.remove = function(n)&#123; var d; if(_.isIE)&#123; if(n &amp;&amp; n.tagName != 'BODY')&#123; d = d || document.createElement('div'); d.appendChild(n); d.innerHTML = ''; &#125; &#125;else&#123; if(n &amp;&amp; n.parentNode &amp;&amp; n.tagName != 'BODY')&#123; n.parentNode.removeChild(n); &#125; &#125;&#125;;为什么jQuery的 getJSON 在进行跨域请求时仍然存在比较严重的内存泄漏？或许是script节点不同于普通的html元素吧，无法按照上述方式删除吧。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript乱弹之（五）：使用脚本创建动态内容","slug":"JavaScript乱弹之（五）：使用脚本创建动态内容","date":"2010-01-28T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2010/01/29/JavaScript乱弹之（五）：使用脚本创建动态内容/","link":"","permalink":"http://yoursite.com/2010/01/29/JavaScript乱弹之（五）：使用脚本创建动态内容/","excerpt":"","text":"document.write()所有支持脚本的浏览器都可以在正文中嵌入document.write()语句。利用它你可以动态的创建内容，不过使用它你需要十分小心。最常见的错误就是在页面加载完毕以后调用，以修改或向页面添加内容。这样的结果只会是用你组装的脚本内容替换掉你的当前页。创建节点创建动态内容标准的方法是使用W3C的document对象的元素创建方法。123456var elem=document.createElement(\"p\");//参数名可以是大写也可以是小写，但是元素elem.tagName的返回值永远是大写。createAttribute( attributeName )createComment( commentString )createDocumentFragment()createTextNode( textString )以上方法全部返回一个节点对象（node object），在没有进行插入操作时，以上方法并不影响DOM的结构。插入和附加节点insertBefore( newChildNode, referenceNode )在现有的子节点前插入一个节点使用方法：parentnode.insertBefore(newNode,childnode)，当childnode为null时作用与appendChild相同。appendChild( newChildNode )将节点添加到指定的节点的最后一个子节点的后面使用方法：parentnode.appendChild(newNode);移除、替换和复制节点removeChild( childNode )replaceChild( newNode, nodeToReplace )cloneNode( true/false)True表示深克隆，所有子节点也被克隆；false表示浅克隆，不会复制子节点。设置节点的属性有两种常用的方式：123var elem=document.createElement(\"div\");elem.setAttribute(\"id\",\"testDIV\");elem[\"id\"]=\"testDIV\";浏览器能够同等识别以上两种方法，W3C推荐第一种，但是由于第一种在IE经常无法改变属性的值，所以最好还是用第二种。innerHTMLIE4引入了两个基于文本的元素对象属性：innerText和innerHTML，由于innerHTML的大量使用而且实用性很强，以至于原本那些许多以“标准”自居的浏览器在严格遵守W3C DOM戒律方面有所放宽，并实现了innerHTML。FireFox并不支持innerText。请你记住innerHTML的开创者是IE！节点的常用属性nodeNamenodeValuenodeTypeparentNodechildNodesAttributesfirstChildlastChildownerDocumentpreviousSiblingnextSiblingtagNamenodeType对应值与类型1 Element2 Attribute3 Text8 Comment9 Document10 DocumentType自定义的insertAfter方法12345678910function insertAfter(newEl, targetEl)&#123; var parentEl = targetEl.parentNode; if(parentEl.lastChild == targetEl) &#123; parentEl.appendChild(newEl); &#125;else &#123; parentEl.insertBefore(newEl,targetEl.nextSibling); &#125; &#125;思路：首先找到目标节点的父节点，如果目标节点是父节点的最后一个子节点，则使用appendChild方法；如果不是最后一个节点则使用JavaScript内置的insertBefore方法插入到目标节点的下一个兄弟节点之前。使用方法：1234var txtName = document.getElementById(\"txtName\");var htmlSpan = document.createElement(\"span\");htmlSpan.innerHTML = \"This is a test\";insertAfter(htmlSpan,txtName);将htmlSpan 作为txtName 的兄弟节点插入到txtName 节点之后","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript乱弹之（四）： 关于Form(ASPX)，你必须知道的","slug":"JavaScript乱弹之（四）：-关于Form-ASPX-，你必须知道的","date":"2010-01-27T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2010/01/28/JavaScript乱弹之（四）：-关于Form-ASPX-，你必须知道的/","link":"","permalink":"http://yoursite.com/2010/01/28/JavaScript乱弹之（四）：-关于Form-ASPX-，你必须知道的/","excerpt":"","text":"在aspx页面中，可以使用Request.Form[“controlname”]来得到控件value属性。那么这些控件必须是哪些类型的控件呢？所有HTML元素里面的input元素，但是还需要另外一个条件就是这个input元素必须要有name属性，id属性可有可无。可能你问如果多个元素的name属性相同怎么办？如果name相同则这些元素的value以逗号分隔，形如“value1,value2”。如果你使用的是服务器控件那么在生成的aspx页面中会自动给所有服务器控件加上name属性，这个name和id的值是相同的。不过当存在母板页时可能会要加上形如“ctl00ContentPlaceHolder”的标记，这些只要看看aspx源码就知道了。另外在Request.Form这是一个NameValueCollection，你可以使用如下代码看看本页面中的表单请求：123 For(int i=0;i&lt;Request.Form.Count;i++)&#123;textbox1.Text+=Request.Form[i]+\",\"; &#125;你会发现多了最后textbox1呈现的结果比你vs编辑器里的input元素总是多2个，而且这两个都是很长的“乱码”。其实这些就是ViewState，你可以去MSDN查看相关介绍。另外所有的服务器控件最后都是转化为HTML控件的，这个转化因控件不同复杂性也不同，比如TreeView转化为HTML控件之后就是DIV嵌套TABLE形成的，这里不详述，自己拖一个看看就知道关系了。另外你有可能需要通过脚本来操作隐藏的控件，这个时候你需要注意这个控件是服务器控件还是HTML控件以及你如何隐藏这些控件。服务器控件可以简单的设置Visible=”false”来隐藏控件，但是一旦这样隐藏，在页面源码中你就找不到该控件的HTML代码了。也就是说，你通过脚本是无法找到该控件的，只有在后台编码中可以使用该控件。但是如果你是通过css来控制的，通过脚本就可以找到。虽然如此你仍然需要掌握css两种不同的隐藏元素的方法：display:none和visibility:hidden,区别在于后者在页面中仍然占据物理空间，前者则通过其他文本流或控件元素自动填补。你拖两个这样的控件，去尝试一下在页面上右键复制这两个控件。html控件的只能通过css来设置其显隐，虽然在vs编辑器里有一个visible属性但是那只有当该控件加上runat=”server”才有效。一旦如此它就是HTML服务器控件了。暂时到这吧，以后继续更新。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript乱弹之（三）：管理浏览器窗口","slug":"JavaScript乱弹之（三）：管理浏览器窗口","date":"2010-01-26T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2010/01/27/JavaScript乱弹之（三）：管理浏览器窗口/","link":"","permalink":"http://yoursite.com/2010/01/27/JavaScript乱弹之（三）：管理浏览器窗口/","excerpt":"","text":"曾几何时，弹出式窗口大行其道，随着浏览器的竞争态势愈演愈烈，虽然给开发者带来极大的不便，但是浏览器的规范化已经成为了共识。如今弹出式窗口的局面已经有效地得到了控制，如果你要在页面中通过脚本打开一个新窗口，那么许多“潜规则”你必须要有所了解。与窗口相关的绝大部分行为都涉及到window对象，window对象涉及大量的属性和方法，但是在不同的浏览器之间确实千差万别。部分原因是由于window对象是脚本任务中最大的全局上下文。IE利用这个上下文为window对象嵌入了许多与浏览器和操作系统相关的属性和方法，而Mozilla却认为window对象的属性会威胁用户的隐私，因此只能通过被服务器打上电子标签的脚本来访问，这些脚本的来源必须经过用户的明确允许（带有签名的脚本）。八条”潜规则”潜规则一：不要修改主窗口的界面元素（chrome）比如状态栏、菜单栏、滚动条、工具栏、标题栏等。唯一的定制窗口界面的方法是打开一个全新的窗口。潜规则二：不要在子窗口中通过脚本关闭主窗口尽管可以使用opener.close()方法来实现。潜规则三：不要试图替用户关闭主窗口之外的其他窗口因为通过脚本你无法得知用户打开了多少个窗口。潜规则四：不要试图访问位于其他域的窗口的文档属性因为这会引发潜在的恶意时间，浏览器都实现了同源安全策略–除非两窗口来自于同一域中的同一服务器，且协议相同，否则不能通过脚本访问另一窗口的关键细节。潜规则五：不要试图阻止或者激活浏览器的窗口按钮许多开发人员希望拦截后退和前进按钮来控制浏览器的导航，但是这些用户动作不会出现在window对象中。潜规则六：不要试图改变地址栏的内容脚本唯一能做的是通过location.href赋值使其渲染新页面。潜规则七：不要试图添加或删除收藏夹的项目在IE中window.external.AddFavorite(“URL”,”Title”)方法可以添加到收藏夹，即使是这个功能，添加之前也会询问用户是否允许。收藏夹是用户私有的，不应该暴露给脚本。潜规则八：不要试图修改浏览器偏好设置Mozilla允许带有签名的脚本应用程序的偏好设置，该功能是网络管理功能。设置窗口的尺寸1.window.resizeTo(800,600);设置窗口为指定尺寸2.window.resizeBy(50,-10);按一定像素增大或缩小窗口调整窗口大小使其符合指定内容大小，并不简单。Mozilla，Opera和Safari提供了一对读写属性可以对窗口的内容区域进行特殊控制–innerHeight和innerwidth，而IE只提供了只读操作document.body.parentNode.clientHeight(clientWidth)。注意：设置窗口的外围尺寸来管理内容区域的思想是糟糕的，用户可能选择工具栏进行设置或者浏览器的操作询问都会影响到你精心设计的布局。移动窗口3.window.moveTo(10,20);移动窗口到指定坐标4.window.moveBy(0,10);按一定像素改变窗口的位置移动窗口时，窗口尺寸不变##最大化主窗口实例：function maximizeWindow()12window.moveTo(0,0);window.resizeTo(screen.availWidth,screen.availHeight);注意：XP真正最大化窗口并没有定位在（0，0）点。其实窗口的左上角位于（-4，-4）。没有真正最大化窗口的方法，也没有最小化窗口的实现方法。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript乱弹之（二）： String","slug":"JavaScript乱弹之（二）：-String","date":"2010-01-25T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2010/01/26/JavaScript乱弹之（二）：-String/","link":"","permalink":"http://yoursite.com/2010/01/26/JavaScript乱弹之（二）：-String/","excerpt":"","text":"单引号与双引号创建字符串的常用方法有以下两种。方法一：var str1=”i love javascript”;方法二：var str2=’i love javascript’;单引号和双引号在JavaScript中的作用是等价的。但是一旦两者混用后就会引发一些麻烦，因此你需要妥善处理。1var mystring=\"i love winslet's sister and nancy's sister\";这种情况你就必须使用转义字符，因为你需要输出单引号而单引号出现了不止一次。当单引号只出现一次时可以不使用转义字符。而当你仅希望将单引号之间的对象当作字符串处理时就不要使用转义字符。字符串对象与字符串值至此，我们需要区分字符串对象和字符串的值。通常来说我们都是只得字符串值。一个字符串对象是这样的：1var strobject=new String(\"i love javascript\");测试一下你会发现strobject的数据类型是Object而不是String,但是他却继承了String所有的属性和方法。连接字符串连接较长的字符串时，你需要特别注意代码中的换行。JavaScript解释器的一个内置特性–在代码的逻辑终点加入分号，所以不能简单的使用回车换行，而应该在该行的最末尾加入“+”。错误的做法：12var strA=\"what i love is csharp ,javascript ,java,phpAnd vb.net\";正确的做法：12var strA=\"what i love is csharp ,javascript ,java,php\"+\"And vb.net\";在合适的地方合理的使用+和;可以减少很多JavaScript代码发生的意外错误。提高字符串处理的性能以前我一致认为字符串这么简单的对象，不管是C#还是JavaScript处理几万个字符的简单累加应该是不需要什么时间的。但是后来发现我错了，当数量超过2万以上时根据机器的性能需要3-15秒的时间。令人诧异吧！C#中可以使用StringBuilder来提高字符串处理的性能，在JavaScript中我们有什么呢？Array！下面的例子一目了然。1234567var Txt=new Array(); Txt.push(\"&lt;tr&gt;\"); Txt.push(\"&lt;td&gt;\"); Txt.push(\"&lt;/td&gt;\"); Txt.push(\"&lt;/tr&gt;\");document.getElementById(\"tbody\").innerHTML=Txt.join(\"\");Txt=null;这个join方法就是在字符串之间加入一个字符，本例是一个空字符，注意不是空白字符” “。Join方法和绝大多数的字符串处理的方法（如indexOf、toUpperCase。即使是replece也不例外）一样并不会改变原字符串（数组）的内容。最后一句让浏览器回收降低内存消耗。检验字符串的相等JavaScript的两种等号操作符：==和===。==完全向后兼容，当两边类型不同时会执行类型转换。例如下面两个对象12var obj=new String(\"123\");var str=\"123\";很明显obj==str将返回true，而===则是严格等号操作不会执行类型转换。类似的可以参见上一节的undefined和null的比较。Unicode值和字符的互相转换对于字符串值和字符串对象，两者是不同的。前者使用charCodeAt(index)后者使用String.fromCharCode(index);另外不要简单的认为Unicode包含了全世界许多语言的文字和字符，就随意的断定知道字符的Unicode值就可以在警告框、文本框、或渲染页面中显示其他语言的特性字符，除非是浏览器和操作系统包含了这些语言。所以你经常在一些大型中文论坛发现很多留学生用英文回帖，其实不是他们不会中文，只是别人的系统和浏览器没有安装中文字体。URL字符串的编码和解码常用的方法有escape和unescape、encodeURI和decodeURL、encodeURIComponent和decodeURIComponent，前者对应编码后者对应解码。编码时普通的字母和数字一般都不会被转换，中文字符以及其他的特殊符号都能被转换。注意：IE浏览器@不能通过escape方法转换。另外Mozilla的浏览器独有的atob（）和btoa（）方法将普通字符串在Base64字符串中相互转换。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript乱弹之（一）：JQuery+CSS入门","slug":"JavaScript乱弹之（一）：JQuery-CSS入门","date":"2010-01-24T16:00:00.000Z","updated":"2017-12-21T23:38:10.000Z","comments":true,"path":"2010/01/25/JavaScript乱弹之（一）：JQuery-CSS入门/","link":"","permalink":"http://yoursite.com/2010/01/25/JavaScript乱弹之（一）：JQuery-CSS入门/","excerpt":"","text":"一直没有系统的学习JavaScript，因为总感觉花太多时间来学习JS似乎有点浪费。现实也似乎是如此，太多人执迷于服务器端语言而忽视了最基本的HTML、JavaScript语言。其中这个“太多人”里面自然也包括我在内。不过本文并不打算去按照一篇HTML语言基础或者JavaScript语言基础教程来介绍这些东西。即使你和我一样是一个新手，阅读他们也不会有什么困难。因为我的宗旨就是在应用中掌握他们，正所谓“书读百遍其义自见”就是这个道理。注明：本系列文章是本人学习笔记和知识摘要，错误之处肯定很多，还请指出。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;%@ Page Language=&quot;C#&quot; AutoEventWireup=&quot;true&quot; CodeFile=&quot;Default.aspx.cs&quot; Inherits=&quot;_Default&quot; %&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head runat=&quot;server&quot;&gt; &lt;title&gt;JS乱弹系列（一）&lt;/title&gt; &lt;%--这里只例举了2种常用的CSS选择器--%&gt; &lt;style type=&quot;text/css&quot;&gt; body &#123; background-color:Black; &#125; #div1 &#123; width:300px; height:50px; background-color:White; border-color:Red; margin-top:1%; margin-bottom:2%; &#125; #div2 &#123; width:417px; height:133px; background-color:White; margin-bottom:2%; &#125; #div3 &#123; width:500px; height:50px; background-color:White; margin-bottom:2%; &#125; #div4 &#123; width:600px; height:50px; background-color:White; margin-bottom:2%; &#125; #div5 &#123; width:700px; height:100px; background-color:White; text-align:center; &#125; &lt;/style&gt; &lt;script src=&quot;JS/jquery-1.3.2-vsdoc2.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;%--加入此引用后，按Crtl+Shift+J更新智能感知#--%&gt; &lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt; $(document).ready(function() &#123; $(&quot;#btn1&quot;).bind(&quot;click&quot;, function() &#123; alert(&quot;绑定成功!&quot;); &#125;) &#125;) $(document).ready(function() &#123; $(&quot;#btn&quot;).bind(&quot;click&quot;, function() &#123; var name = $(&quot;#txtname&quot;).val(); var pwd = $(&quot;#txtpwd&quot;).val(); if (name=== &quot;&quot; || pwd === &quot;&quot;) &#123; alert(&quot;用户名和密码不能为空！&quot;); return false; &#125; else &#123; alert(name + &quot;/&quot; + pwd); return true; &#125; &#125;) &#125;) //假值，按照crockford的建议最好使用===代替== $(document).ready(function() &#123; var a = (undefined == &quot;&quot;); var b = (undefined == null); var c = (undefined == NaN); var d = (undefined === &quot;&quot;); var e = (undefined === null); var f = (undefined === NaN); $(&quot;#div2&quot;).text(String(a) + &quot;\\n&quot; + String(b) + &quot;\\n&quot; + String(c) + &quot;\\n&quot; + String(d) + &quot;\\n&quot; + String(e) + &quot;\\n&quot; + String(f)); &#125;)// 是不是很像C#的typeof $(document).ready(function() &#123; var a =typeof(undefined) ; var b =typeof(null) ; var c =typeof(&quot;&quot;) ; var d = typeof (NaN); $(&quot;#div3&quot;).text(String(a) + &quot;/&quot; + String(b) + &quot;/&quot; + String(c) + &quot;/&quot; + String(d)); &#125;) //存在表单输入时自动聚焦 $(document).ready(function() &#123; document.form1.txtname.focus(); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form id=&quot;form1&quot; runat=&quot;server&quot;&gt; &lt;div id=&quot;divmain&quot;&gt;&lt;div id=&quot;div1&quot;&gt;这是div1&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;这是div2&lt;br/&gt;JavaScript的假值，你知道这些结果是true还是false吗？1.undefined == &quot;&quot;2.undefined == null3.undefined == NaN4.undefined === &quot;&quot;5.undefined === null6.undefined === NaN&lt;/div&gt;&lt;div id=&quot;div3&quot;&gt;这是div3&lt;/div&gt;&lt;div id=&quot;div4&quot;&gt; &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;使用JQuery为按钮绑定事件&quot; title=&quot;在ready函数中绑定button的Click函数&quot;/&gt;&lt;/div&gt;&lt;div id=&quot;div5&quot;&gt;这是模拟一个登陆验证&lt;br /&gt; &lt;span style=&quot;background-color:White&quot;&gt; 账号：&lt;/span&gt;&lt;asp:TextBox ID=&quot;txtname&quot; runat=&quot;server&quot;&gt;&lt;/asp:TextBox&gt; &lt;br /&gt; &lt;span style=&quot;background-color:White&quot;&gt; 密码：&lt;/span&gt;&lt;asp:TextBox ID=&quot;txtpwd&quot; runat=&quot;server&quot;&gt;&lt;/asp:TextBox&gt; &lt;br /&gt; &lt;asp:Button ID=&quot;btn&quot; runat=&quot;server&quot; Text=&quot;登陆验证&quot;/&gt;&lt;/div&gt;&lt;/div&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]}]}